<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.ReSharper.Psi</name>
    </assembly>
    <members>
        <member name="T:JetBrains.ReSharper.Psi.Caches.IWordIndex">
             <summary>
             Allows retrieving project items corresponding to source files 
             containing identifiers with given names.
             This index can be used to narrow search operations on JetBrains.ReSharper.Psi.CSharp.
             </summary>
             <example>
             Example demostrates narrowing of search domain:
             <code>
            ISearchDomain NarrowSearchDomain (ISearchDomain searchDomain, IDeclaredElement elementToSearch)
            {
              WordIndex wordIndex = WordIndex.GetInstance (elementToSearch.GetManager().Solution );
              IProjectItem [] itemsContainingNames = wordIndex.GetFilesContainingWords (elementToSearch.ShortName);
              ISearchDomain newDomain = SearchDomainFactory.CreateSearchDomain (itemsContainingNames);
              return SearchDomainFactory.CreateIntersectionDomain (searchDomain,newDomain);
            }
             </code>
             <seealso cref="T:JetBrains.ReSharper.Psi.Search.IFinder"/>
             </example>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IWordIndex.GetFilesContainingWord(System.String)">
             <summary>
             Returns array of project items corresponding to all source code files 
             containing identifiers which text is equal to given word
             </summary>
            <param name="word"></param>
            <remarks>Returns empty array if empty array is passed or no such files found.
             Does not expect null to be passed (throws exception)</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IWordIndex.GetFilesContainingWords(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns array of project items corresponding to all source code files 
            containing identifiers which text is equal to any of given words
            </summary>
            <remarks>Returns empty array if empty array is passed or no such files found.
            Does not expect null to be passed (throws exception)</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IWordIndex.ContainsWord(JetBrains.ProjectModel.IProjectFile,System.String)">
            <summary>
            Check if file contains given word
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IWordIndex.GetWords(System.String,JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.IWordIndexLanguageProvider)">
            <summary>
            Tokenize
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatterHelper">
            <summary>
            Helper methods to work with <see cref="T:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.CodeFormatterHelper.FormatFile(JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter,JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile)">
            <summary>
            Format the whole file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.FormatFile(JetBrains.ReSharper.Psi.Tree.IFileNode,JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Format the whole file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.Format(JetBrains.ReSharper.Psi.Tree.IElement,JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Format the given subtree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.Format(JetBrains.ReSharper.Psi.Tree.IElement,JetBrains.ReSharper.Psi.Tree.IElement,JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Format the given range in the tree. The bounding nodes are random, not siblings
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.Format(JetBrains.ProjectModel.ISolution,JetBrains.DocumentModel.DocumentRange,JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings,JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile,System.Boolean,System.Boolean,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Format the given range in document
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.FormatInsertedNodes(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,System.Boolean)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.FormatInsertedRange(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.ITreeRange)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.FormatReplacedNode(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.FormatDeletedNodes(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Format code during WritePSI action
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter.GetMinimalSeparator(JetBrains.ReSharper.Psi.Tree.ITokenNode,JetBrains.ReSharper.Psi.Tree.ITokenNode)">
            <summary>
            Create the necessary separator between two given tokens (for example. space between identifiers)
            If there is no necessity for separator, then return <c>null</c>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.ISymbolTable.Names(System.String)">
            <summary>
            Get all names from the symbol table, starting from the given prefix <paramref name="prefix"/>. 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking">
            <summary>
            This class describes positions of different components of the string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            This class is used as <code>out</code> parameter in calls to <see cref="M:JetBrains.ReSharper.Psi.IDeclaredElementPresenter.Format(JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle,JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking@)"/> methods.
            See <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElementPresenter"/> methods for examples of use.
            <seealso cref="T:JetBrains.ReSharper.Psi.IDeclaredElementPresenter"/>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.EntityKindRange">
            <summary>
            The declared element entity kind range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.AccessRightsRange">
            <summary>
            The declared element access rights range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ModifiersRange">
            <summary>
            The declared element modifier words range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.TypeRange">
            <summary>
            The declared element type (for variables) or return type (for functions) range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ScalarTypeRange">
            <summary>
            The declared element scalar type range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            E.g. in the string "int [] x" the scalar type range of "x" is the range of "int".
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ExplicitInterfaceRange">
            <summary>
            Range of the explicit interface qualification of the member.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.NameRange">
            <summary>
            The declared element name range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ParameterListRange">
            <summary>
            The declared element parameter list range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.TypeParameterListRange">
            <summary>
            The declared element type parameter list range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.TypeParameterRanges">
            <summary>
            An array of the declared element type parameter ranges in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ParameterRanges">
            <summary>
            An array of the declared element parameter ranges in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ContainerRange">
            <summary>
            The declared element container (type or namespace) range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            //TODO: what it returns for parameter?
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ContainerNameRange">
            <summary>
            The range of the name of the container.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.ConstantValueRange">
            <summary>
            The range of the value of a constant or a local constant in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter">
            <summary>
            This class describes position of parameter-related components of the string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            An instance of this class is stored in the marking per each parameter of the formatted <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.Range">
            <summary>
            The paramter range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.KindRange">
            <summary>
            The paramter kind range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.TypeRange">
            <summary>
            The paramter type range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.ScalarTypeRange">
            <summary>
            The range of scalar type of the parameter type in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            E.g. in the string "void Foo(int [] x)" the scalar type range of parameter "x" is the range of "int".
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking.Parameter.NameRange">
            <summary>
            The paramter name range in a string presenting <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElement.GetProjectFiles">
            <summary>
            Get the set of project files which contains the declaration of this element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElement.HasDeclarationsInProjectFile(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Checks if there are declarations of this element in given <paramref name="projectFile"/>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IDeclaredElement.Language">
            <summary>
            Get the language on which this element is declared
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IXmlDocIdOwner.XMLDocId">
            <summary>
            Identifier of this member in XML documentation file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiModule.GetReferences">
            <returns>All referenced modules with aliases</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiModule.GetPreImportedNamespaces(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Get pre-imported namespaces for specific project file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiModule.GetDefaultNamespace(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Default namespace for specific project file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiModule.IsStrictOff(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Is option strict OFF for specific project file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiModule.IsExplicitOff(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Is option explicit OFF for specific project file
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPsiModule.DisplayName">
            <summary>
            Module name to display in UI
            For regular modules the same as Name
            Primary for web modules useful
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.EntityKindForm">
            <summary>
            Indicates how declared element entity kind is presented:
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show entity kind (default value)</description></item>
            <item><term>NORMAL</term><description>namespace</description></item>
            <item><term>NORMAL_IN_BRACKETS</term><description>(in namespace)</description></item>
            <item><term>IN</term><description>in namespace</description></item>
            <item><term>FROM</term><description>from namespace</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint">
            <summary>
            Represents an expectation constraint
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint.Accepts(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if a type matches the constraint
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint.GetDefaultType">
            <summary>
            Gets some default appropriate type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint.GetDefaultTypes">
            <summary>
            Gets some default appropriate types
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint.GetTypesEffectively">
            <summary>
            Gets array of expected types if can be performed effeciently 
            </summary>
            <returns>
              null  if ineffective
              array of types if fast
            </returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetElement">
            <summary>
            Returns the "owner" (tail) of the reference.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetName">
            <summary>
            Returns reference name.
            This name usually coincides with short name of corresponding DeclaredElement.
            (Only known exception is constructor initializer, its name is "this" or "base".)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetAllNames">
            <summary>
            Returns all reference names (i.e., all possible short names of corresponding DeclaredElement)
            <remarks>Can be invoked on invalid refernce!</remarks>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetReferenceSymbolTable(System.Boolean)">
            <summary>
            Returns full symbol table for the reference
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.Resolve">
            <summary>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetTreeTextRange">
            <summary>
            Returns text range of reference in the source file.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.CheckResolveResult">
            <summary>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.BindTo(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Bind this reference to given Declared Element. May insert using directive.
            </summary>
            <returns>new "this"</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.BindTo(JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <summary>
            Bind this reference to given Declared Element and substitution. May insert using directive.
            </summary>
            <returns>new "this"</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReference.GetAccessContext">
            <summary>
            Returns access context containing reference. It is useful to define, if context
            is static or to determine access rights of context.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.IReference.ReferenceType">
            <summary>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.IReference.HasMultipleNames">
            <summary>
            Returns true iff reference could be resolved in declared elements with different names.
            E.g., attribute [XXX] could be resolved into class with name 'XXX' or 'XXXAttribute' 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedReferenceBase`1.GetAllNames">
            <summary>
            Override this method if your reference has muiltiple names
            </summary>    
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedReferenceBase`1.HasMultipleNames">
            <summary>
            Override this method if your reference has muiltiple names
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElementExtensions">
            <summary>
            Extensions for <see cref="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElementExtensions.GetChildByRole(JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement,System.Int16)">
            <summary>
            NotNull version of <see cref="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement.FindChildByRole(System.Int16)"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.GetFirstClassReferences">
            <summary>
            Get references which should be visited by resolver, and which are syntax-dependednt (not semantic)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.GetContainingElement``1(System.Boolean)">
            <param name="returnThis">Whether to include the starting element.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.Contains(JetBrains.ReSharper.Psi.Tree.IElement)">
            <summary>
            Returns true if the subtree rooted at this element contains other element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.IsPhysical">
            <summary>
            Checks if this element is located at physical file (and not in dummy holder).
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.Copy(JetBrains.ReSharper.Psi.Tree.IElement)">
            <summary>
            Creates the copy of this element and puts it into dummy holder.
            Use <see cref="M:JetBrains.ReSharper.Psi.Tree.ElementExtensions.CopyElement``1(``0,JetBrains.ReSharper.Psi.Tree.IElement)"/> for strongly-typed variant
            </summary>
            <param name="context">context for resolving, or <c>null</c> for none</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.CopyWithResolve">
            <summary>
            Creates the copy of this element and puts it into dummy holder.
            All references in the copy are fake-resolved.
            Use <see cref="M:JetBrains.ReSharper.Psi.Tree.ElementExtensions.CopyElementWithResolve``1(``0)"/> for strongly-typed variant
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.IsValid">
            <summary>
            Checks if this element is valid
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.GetNavigationRange">
            <summary>
            Returns an offset in the text to move caret to when positioning to the element
            </summary>
            <returns>An offset in the text</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.GetText(System.Text.StringBuilder)">
            <return> Implementations must always return parameter.</return>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.GetText">
            <summary>
            Returns text representation of an element
            </summary>
            <remarks>For performance reason, it's better to use another GetText method</remarks>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.FindElementAt(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Finds the smallest element containing the specified text range
            </summary>
            <param name="treeTextRange">Text range in this element</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.FindElementsAt(JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            Finds all elements containing the specified offset and such that none of the elements
            contains another element meeting this condition
            </summary>
            <param name="treeTextOffset">Offset to find element at</param>
            <returns>Array of found elements, or an empty array</returns>
            <remarks>If an element returned by this method is not a leaf, it should be empty</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.FindTokenAt(JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            Returns the token containing the character corresponding to the specified offset
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.FindReferencesAt(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Finds all references whose ranges in text contain the specified text range
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.PutPersistentData``1(JetBrains.Util.Key{``0},``0)">
            <summary>
            Stores given value by specified key. This value will be copied to clones.
            Use <code>PutPersistentData(key, null)</code> to remove the association.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IElement.GetPersistentData``1(JetBrains.Util.Key{``0})">
            <summary>
            Retrieves value associated with given key.
            Returns null when no value is associated.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement.myCachedLocalOffsetInParent">
            <summary>
            Cached value of local node offset in parent. The value is valid only when parent.<see cref="F:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement.myCachedLength"/> is valid
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement.FindElementsAtInternal(JetBrains.ReSharper.Psi.TreeOffset,System.Collections.Generic.List{JetBrains.ReSharper.Psi.Tree.IElement})">
            <returns>Length of this element if it's less or equal than offset or any value greater than offset</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement.FindChameleonWhichCoversRange(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Finds the deepest sub-node implementing IChameleon interface which contains the given range internally
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IDynamicType">
            <summary>
            Dynamic type in CLR 4
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IDeclaredType">
            <summary>
            Interface for types which might have declaration (that is, correspond to some <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/>).
            For example, "IDeclaredType" and "int" are declared types.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IType">
            <summary>
            Represents a type. 
            Instances of <c>IType</c> can be compared by <see cref="M:System.Object.Equals(System.Object)"/> and are equal 
            if they represent the same type.
            </summary>
            <seealso cref="T:JetBrains.ReSharper.Psi.IDeclaredType"/>
            <seealso cref="T:JetBrains.ReSharper.Psi.IArrayType"/>
            <seealso cref="T:JetBrains.ReSharper.Psi.IDeclaredType"/>
            <seealso cref="T:JetBrains.ReSharper.Psi.IPointerType"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.IsImplicitlyConvertibleTo(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Checks if this type can be implicitly converted to given type by the rules of the <param name="languageType"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.IsExplicitlyConvertibleTo(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Checks if this type can be explicitly converted to given type by the rules of the <param name="languageType"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.GetLongPresentableName(JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Returns some presentation string for this type in which all names are shown in fully qualified form. 
            For example, for "System.Drawing.Point[]" it will be "System.Drawing.Point[]"
            and for "System.Int32" it will be "int".
            </summary>
            <remarks>
            Note: long presentable name should not be used for any purposes except presentation.
            For example, it should not be parsed to restore any information about original type.
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.GetManager">
            <summary>
            Get the PSI manager
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExpressionType.IsValid">
            <summary>
            Check if this type is valid, i.e. referes to valid declared elements
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExpressionType.IsResolved">
            <summary>
            Check if the type is resolved successfully (and it's substitution is resolved correctly)
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExpressionType.IsUnknown">
            <summary>
            Check if this type is unknown, i.e. it can't have correct presentation
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IType.GetPresentableName(JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Returns some presentation string for this type. 
            For example, for "System.Drawing.Point[]" it will be "Point[]"
            and for "System.Int32" it will be "int".
            </summary>
            <remarks>
            Note: presentable name should not be used for any purposes except presentation.
            For example, it should not be parsed to restore any information about original type.
            </remarks>
            <seealso cref="M:JetBrains.ReSharper.Psi.IExpressionType.GetLongPresentableName(JetBrains.ReSharper.Psi.PsiLanguageType)"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IType.GetScalarType">
            <summary>
            Returns type of the scalar value of this type.
            For examples for "int", "int[]", "int[][]" and "int*" it returns "int".
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IType.IsWellFormed">
            <summary>
            Checks whether values of all type parameters satisfies their constrains
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IType.IsOpenType">
            <summary>
            According to C# specs 25.5.2
            <list type="bullet">
            <item>type parameter defines an open type</item>
            <item>An array type is an open type if and only if its element type is an open type</item>
            <item>A constructed type is an open type if and only if one or more of its type arguments is an open type. A
              constructed nested type is an open type if and only if one or more of its type arguments or the type
              arguments of its containing type(s) is an open type</item>
            </list>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IType.Classify">
            <summary>
            Get the type kind. Returns <c>null</c> is can't classify this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IType.Module">
            <summary>
            Get the module where this type was built
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredType.GetTypeElement">
            <summary>
            Returns ITypeElement corresponding to this type. 
            Can return null when it cannot "resolve" this type.
            For example, this can happen when you get type of a variable and
            the corresponding type usage in the source code cannot be resolved
            (that is, the code is not compilable).
            </summary>
            <returns>ITypeElement corresponding to this type or null if the type cannot be resolved.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredType.GetCLRName">
            <summary>
            CLR name of the type
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IDeclaredType.Assembly">
            <summary>
            Assembly name of the assembly where this type is defined, or null if unspecified
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.ICache.Update(System.Collections.Generic.ICollection{JetBrains.ProjectModel.IProjectFile})">
            <summary>
            Synchronously update caches
            </summary>
            Happens either when <see cref="M:JetBrains.ReSharper.Psi.PsiManager.CommitAllDocuments"/> or <see cref="M:JetBrains.ReSharper.Psi.PsiManager.UpdateCaches"/> 
            is called
            <param name="commitedPsi">list of files commited right before updating caches</param>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.Caches2.SymbolCache.ForwardedTypesTable.myForwardedTypesByClrName">
            <summary>
            CLRTypeName => {ForwardedTo, ForwardedFrom}
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.Caches2.SymbolCache.ForwardedTypesTable.myForwardedNamespaces">
            <summary>
            For every assembly, stores set of types' namespaces forwarded to it
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.CodeStyle.CodeFormatterBase">
            <summary>
            Base implementation of <see cref="T:JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentCacheBase.GetLineIndent(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Get the indentation of the line which contains given node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentCacheBase.GetNodeIndent(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Get the exact indentation of the given node
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IPsiIconManagerExtension">
            <summary>
            Custom declared elemet image provider
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiIconManagerExtension.GetImage(JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Provides custom image for declared element with given requested presentation language. 
            If image is providen, return pair of image and flag. 
            If flag is <c>true</c> then extensions could be appended to image, and <c>false</c> if image is complete
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.DeclaredElementPointer">
            <summary>
            Implements element pointer funcitonality
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.DeclaredElementPointer.#ctor(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Creates new smart element pointing to the specified declared element
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.IRangeTranslator">
            <summary>
            Document range translator
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.IAssemblyDataCache.OnAssemblyLoadingFinished">
            <summary>
            Called when assembly loading is finished, so temporary data could be cleared
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Reflection2.IAssemblyDataCache.AssemblyName">
            <summary>
            Primary assembly name for which this cache was created
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Reflection2.AssemblyDataCacheIntern.AssemblyName">
            <summary>
            Primary assembly name for which this cache was created
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.DefaultPsiModuleProviderFactory">
            <summary>
            PSI module provider for regular projects
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiModuleProviderFactory.CreateProvider(JetBrains.ProjectModel.IProject)">
            <summary>
            Creates module provider if it can handle the project of this type.
            Returns <c>null</c> if can't handle
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiModuleProvider.GetPrimaryModule">
            <summary>
            Module which reflects project output assembly
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiModuleProvider.GetSecondaryModules">
            <summary>
            Additional modules found in project
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPsiModuleProvider.GetModuleFor(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Get the PSI module for given project file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope">
            <summary>
            Any PSI change inside this scope:
            <list type="number">
            <item>Affects resolve validity of inner references only</item>
            <item>Does not change 'global' model</item>
            </list>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope.ModificationStamp">
            <summary>
            Returns <c>null</c> if this element actually is not scope.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.OutputAssembliesCache.RemoveProjectOutputAssembly(JetBrains.ProjectModel.IProject)">
            <returns>Old output assembly</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.OutputAssembliesCache.GetAssemblyByProject(JetBrains.ProjectModel.IProject)">
            <returns>Assembly if it is specified for project and there's no other project with the same 
            output assembly</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.OutputAssembliesCache.GetProjectByAssembly(JetBrains.ProjectModel.IAssembly)">
            <returns>Project if it is the only project with output assembly equal to the assembly in question</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.IReferenceProvider">
            <summary>
            Custom reference provider
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReferenceProvider.GetReferences(JetBrains.ReSharper.Psi.Tree.IElement,System.Collections.Generic.ICollection{System.String})">
            <summary>
            References which depends on first class references. 
            If <paramref name="names"/> is null, all references should be enumerated.
            If not null, then there might be an optimization to return only the references
            which might have given name
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IPsiModuleReference">
            <summary>
            Reference between PSI modules
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Types.DynamicTypePointer">
            <summary>
            Pointer to the 'dynamic' type. 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ITypePointer">
            <summary>
            Interface for obtaining a type from some place
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypePointer.FindType">
            <summary>
            Resurrects the type being pointed to
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypePointer.Solution">
            <summary>
            Solution in which the pointer was created
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.UnsupportedProjectPsiModuleProviderFactory">
            <summary>
            PSI module provider for regular projects
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.IMiscFilesProjectPsiModuleProvider.GetModules">
            <summary>
            Get provided modules
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.IMiscFilesProjectPsiModuleProvider.GetModuleFor(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Get the PSI module for given project file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.MiscFilesProjectPsiModuleProviderFactory">
            <summary>
            PSI module provider for special solution projects
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.ILanguageSpecificSearcherFactory">
            <summary>
            Language service should implement the searcher factory to allow the finder look into files with specific language
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ILanguageSpecificSearchWordsProvider.GetAllPossibleWordsInFile(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Enumerate words which should occur in the file to contain reference to <paramref name="element"/>. 
            Return <c>null</c> or <see cref="F:System.String.Empty"/> in enumeration to switch word filtering off
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ILanguageSpecificSearcherFactory.GetRelatedDeclaredElements(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Get the declared elements which should be searched for along with the given element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ILanguageSpecificSearcherFactory.GetDerivedFindRequest(JetBrains.ReSharper.Psi.Search.FindResultReference)">
            <summary>
            Get the derived find request. When "Find Usages' found reference, this can return few more declared elements which should be found.
            </summary>
            <returns>Collection of declared elements which should be searched, predicate if their result should be consumed, and boolean value indicating if original find result is relevant, i.e. should be consumed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ILanguageSpecificSearcherFactory.GetNavigateToTargets(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Provider could override "Goto declaration" behavour, by providing preferred elements
            The <c>bool</c> value indicatis wether the original navigation target is relevant, out should be omitted
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ILanguageSpecificSearcherFactory.TransformNavigationTargets(System.Collections.Generic.ICollection{JetBrains.ReSharper.Psi.Search.FindResultDeclaration})">
            <summary>
            Provider could transform navigation targets through this method.
            If not transformed, return the original collection or <c>null</c>. If transformed, return new one
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.ILanguageSpecificSearcherFactory.Language">
            <summary>
            Get the language for which this factory works. If it is applicable to many languages, return <see cref="F:JetBrains.ReSharper.Psi.PsiLanguageType.ANY"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ILanguageSpecificSearcher.ProcessProjectItem``1(JetBrains.ProjectModel.IProjectFile,JetBrains.ReSharper.Psi.Search.IFindResultConsumer{``0})">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ILanguageSpecificSearcher.ProcessElement``1(JetBrains.ReSharper.Psi.Tree.IElement,JetBrains.ReSharper.Psi.Search.IFindResultConsumer{``0})">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.SearcherBase.ProcessProjectItem``1(JetBrains.ProjectModel.IProjectFile,JetBrains.ReSharper.Psi.Search.IFindResultConsumer{``0})">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.SearcherBase.ProcessElement``1(JetBrains.ReSharper.Psi.Tree.IElement,JetBrains.ReSharper.Psi.Search.IFindResultConsumer{``0})">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.SearcherBase.ProcessLibraryFile``1(JetBrains.ReSharper.Psi.Caches.ILibraryFile,JetBrains.ReSharper.Psi.Search.IFindResultConsumer{``0})">
            <returns>True if further search is not needed</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.GeneratedRangeMap`1.Add(JetBrains.Util.TextRange,JetBrains.ReSharper.Psi.Impl.Shared.ElementRange{`0})">
            <summary>
             Adds new generated pair
            </summary>
            <param name="generatedRange">TextRange in generated code</param>
            <param name="originalRange">Source range, if originalRange == ElementTange{T}.Invalid, the range is secondary</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Shared.GeneratedRangeMap`1.Append(JetBrains.ReSharper.Psi.Impl.Shared.GeneratedRangeMap{`0},System.Int32)">
            <summary>
            Used while code generation only
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IQualifiableReference.IsQualified">
            <remarks>
            When IsQualified is true that doesn't mean GetQualifier is not null!
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IAccessContext.GetStaticness">
            <summary>
            Determines whether static members are accessible in this context.
            Staticness should be consistent with qualifier kind of access context.
            All qualifier 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement.FindChildByRole(System.Int16)">
            <summary>
            Search for the child with given role
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement.GetNextFilteredChild(JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement)">
            <summary>
            To be overriden for each language.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiModuleReferenceExtensions.IsExternAliasGlobal(JetBrains.ReSharper.Psi.IPsiModuleReference)">
            <summary>
            Checks if alias list got by <see cref="M:JetBrains.ReSharper.Psi.PsiModuleManager.GetModuleReference(JetBrains.ReSharper.Psi.IPsiModule,JetBrains.ReSharper.Psi.IPsiModule)"/> denotes for global alias
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ICrossProjectAnonymousTypeImpl">
            <summary>
            Solution wide and cross language anonymous type implementation.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.MemberContainerStyle">
            <summary>
            Indicates where the container type of a type member should be shown.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type (default value)</description></item>
            <item><term>AFTER</term><description>foo() in ClassName</description></item>
            <item><term>AFTER_WITH_KIND</term><description>foo() in class ClassName</description></item>
            <item><term>AFTER_IN_PARENTHESIS</term><description>foo() (in ClassName)</description></item>
            <item><term>AFTER_IN_PARENTHESIS_WITH_KIND</term><description>foo() (in class ClassName)</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.NamespaceContainerStyle">
            <summary>
            Indicates if the containing type of a <see cref="T:JetBrains.ReSharper.Psi.INamespace"/> should be shown and where it should be shown.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type (default value)</description></item>
            <item><term>AFTER</term><description>Namespace in Namespace</description></item>
            <item><term>AFTER_IN_PARENTHESIS</term><description>Namespace (in Namespace)</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.NameStyle">
            <summary>
            Indicates how the entity name shold be presented
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show name (default value)</description></item>
            <item><term>SHORT</term><description>Show name in short form</description></item>
            <item><term>SHORT_RAW</term><description>Show name in short non-verbatim form</description></item>
            <item><term>QUALIFIED</term><description>Show name in fully qualified form</description></item>
            <item><term>QUALIFIED_EXCEPT_MEMBERS</term><description>Show name in fully qualified form if the element is not type member</description></item>
            <item><term>FULL_NESTED_TYPE</term><description>Full nested type name without namespace</description></item>
            <item><term>FULL_NESTED_TYPE_EXCEPT_MEMBERS</term><description>Full nested type name without namespace if the element is not type member</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Naming.INameCanoniser">
            <summary>
            Interface for components performing language-specific canonisation of symbol names. 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.INameCanoniser.GetCanonicalShortName(System.String)">
            <summary>
            Canonises language-specific short name by returning the CLR-compilant equivalent
            </summary>
            <param name="name">Language-specific name (possibly escaped)</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.INameCanoniser.GetCanonicalQualifiedName(System.String)">
            <summary>
            Converts language-specific qualified name into CLR-compliant equivalent
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ParameterContainerStyle">
            <summary>
            Indicates if the containing method should be shown and where it should be shown if the given element is a parameter.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show method (default value)</description></item>
            <item><term>AFTER</term><description>parameter a of method foo</description></item>
            <item><term>AFTER_IN_PARENTHESIS</term><description>parameter a (of method foo)</description></item>
            </list>
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.PsiStrategyHint.NONE">
            <summary>
            No hints. Default
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.PsiStrategyHint.OPEN_CHAMELEONS">
            <summary>
            Pre-open chameleons
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.PsiStrategyHint.INCREMENTAL">
            <summary>
            Store data for incremental reparse, for example tokens
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.PsiStrategyHint.NO_CACHING">
            <summary>
            Do not store file in cache
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Search.FindResult.MasterResult">
            <summary>
            For original (i.e. first-class) result, this is <c>null</c>.
            For related search, this points to original result.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Search.FindResultOverridableMember.QuasiBasisElement">
            <summary>
            Type element which was used as basis for quasi-implemetation
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.FromLength(JetBrains.ReSharper.Psi.TreeOffset,System.Int32)">
            <summary>
            Creates a new range from offset and length, rather than from start + end offsets, as the <c>.ctor</c> would do.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.FromLength(System.Int32)">
            <summary>
            Creates a new range from zero offset and length, rather than from start + end offsets, as the <c>.ctor</c> would do.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.GetMinOffset">
            <summary>
            Gets the <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.StartOffset"/> or <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.EndOffset"/>, whichever is smaller. Use for consistent processing of potentially non-normalized ranges.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.GetMaxOffset">
            <summary>
            Gets the <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.StartOffset"/> or <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.EndOffset"/>, whichever is greater. Use for consistent processing of potentially non-normalized ranges.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.ContainedIn(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Gets whether this range is a subset of the <paramref name="treeRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.StrictContainedIn(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Gets whether this range is a proper subset of the <paramref name="treeRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.Contains(JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            Determines whether the offset falls within the range, start and end offsets included.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.ContainsCharIndex(JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            <para>Checks whether the character at the <paramref name="charindex">given index</paramref> falls within this range.</para>
            <para>Unlike <see cref="!:Contains(int)"/>, the right offset is not included, because the range ends before the character with such an index.</para>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.IsValid">
            <summary>
            Checks that the range is not the <see cref="F:JetBrains.ReSharper.Psi.TreeTextRange.InvalidRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.AssertValid">
            <summary>
            Asserts that this range is normalized, which means that its <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.Length"/> is nonnegative.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.AssertNormalized">
            <summary>
            Asserts that this range is normalized, which means that its <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.Length"/> is nonnegative.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.Normalized">
            <summary>
            Returns a normalized version of the current text range (with a nonnegative length).
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TreeTextRange.DistanceTo(JetBrains.ReSharper.Psi.TreeOffset)">
            <summary>
            Returns the distance between the <paramref name="offset"/> and the nearest point that belongs to the range.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.TreeTextRange.IsNormalized">
            <summary>
            Gets whether this range is normalized, which means that its <see cref="P:JetBrains.ReSharper.Psi.TreeTextRange.Length"/> is nonnegative.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ElementExtensions.GetProjectFileRange(JetBrains.ReSharper.Psi.Tree.IElement)">
            <summary>
            Get the coordinates of this subtree in real document
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.ElementExtensions.GetDocumentRange(JetBrains.ReSharper.Psi.Tree.IElement)">
            <summary>
            Get the coordinates of this subtree in real document
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IConstantValueOwner.ConstantValue">
            <summary>
            Calculate compile time constant value 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IExpression.Type">
            <summary>
            Type of expression. This function never returns null, if type cannot be determined it returns UnknownType.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TypeContainerStyle">
            <summary>
            Indicates if the containing type or namespace of a <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> should be shown and where it should be shown.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type (default value)</description></item>
            <item><term>AFTER</term><description>ClassName in Namespace</description></item>
            <item><term>AFTER_WITH_KIND</term><description>ClassName in namespace Namespace</description></item>
            <item><term>AFTER_IN_PARENTHESIS_WITH_KIND</term><description>ClassName (in namespace Namespace)</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TypeParameterStyle">
            <summary>
            The style of the type parameters presenting.
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type parameters</description></item>
            <item><term>CLR</term><description>CLR-style, i.e. the number of type parameters after `</description></item>
            <item><term>INDICATE</term><description>Shows syntax indicating presense of type parameters, but doesn't list them</description></item>
            <item><term>FULL</term><description>Show type parameters with their names(default value)</description></item>
            <item><term>FULL_WITH_VARIANCE</term><description>Show type parameters with their names(default value) and in/ outs</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TypeStyle">
            <summary>
            Indicates how return type of a function or type of a variable are presented
            <list type="table">
            <listheader><term>Enum member name</term><description>Description or example</description></listheader>
            <item><term>NONE</term><description>Do not show type (default value)</description></item>
            <item><term>BEFORE</term><description>Language default (for example: Type foo)</description></item>
            <item><term>AFTER</term><description>foo:Type</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IModifiersOwner">
            <summary>
            Interface for a language construction that may have modifiers
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IAccessRightsOwner">
            <summary>
            Interface for a language construction that may have access rights modifiers
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.AccessibilityDomain">
            <summary>
            The accessibility domain of some type member
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PUBLIC">
            <summary>
            Unrestricted access to member
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.INTERNAL">
            <summary>
            Access is restricted to assembly, in which member is defined
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PROTECTED">
            <summary>
            Access is restricted to <see cref="P:JetBrains.ReSharper.Psi.AccessibilityDomain.Container"/> and it derivates
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PROTECTED_OR_INTERNAL">
            <summary>
            Access is restricted to <see cref="P:JetBrains.ReSharper.Psi.AccessibilityDomain.Container"/>, all it derivates, and the assembly where member is defined
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PROTECTED_AND_INTERNAL">
            <summary>
            Access is restricted to <see cref="P:JetBrains.ReSharper.Psi.AccessibilityDomain.Container"/> and it derivates in assembly where member is declared
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.PRIVATE">
            <summary>
            Access is restricted to <see cref="P:JetBrains.ReSharper.Psi.AccessibilityDomain.Container"/> only
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.AccessibilityDomain.AccessibilityDomainType.NONE">
            <summary>
            Error occured while computing accessibility domain
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CachedPsiValue`1.GetValueRaw">
            <summary>
            Get value regardless of timastamp
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CachePersistenceSettingsManager.GetGlobalCacheFolder">
            <summary>
            Get the cache folder for global entities. 
            The value is <c>null</c> if do not use global cache - everything should be stored in solution
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.DeclarationsScopeFactory.SolutionScope(JetBrains.ProjectModel.ISolution,System.Boolean)">
            <summary>
            Creates whole solution or solution without libraries scope.
            </summary>
            <remarks>solution should not be <code>null</code></remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.DeclarationsScopeFactory.ModuleScope(JetBrains.ReSharper.Psi.IPsiModule,System.Boolean)">
            <summary>
            Creates either project either assembly scope
            </summary>
            <remarks>library should not be null <code>null</code></remarks>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.IDeclarationsScope">
            <summary>
            Repsents scope of declarations cache.
            Scope can be one of :
            <list>
            <item>whole solution including libraries - covers types and namespaces in solution</item>
            <item>whole solution exclusing libraries - covers types and namespaces in source code of solution</item>
            <item>project - covers types and namespaces in source code of given project</item>
            <item>project and its referenced libraries and projects- covers types and namespaces in given project and its references including transitive ones</item>
            <item>library and its referenced libraries - covers types and namespaces in given library and libraries referenced by it</item>
            </list>
            Declaration scope is created through <see cref="T:JetBrains.ReSharper.Psi.Caches.DeclarationsScopeFactory"/> class
            <example>See <see cref="T:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache"/> for example of use.</example>
            </summary>
            <seealso cref="T:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache">DeclarationsCache</seealso>
            <seealso cref="M:JetBrains.ReSharper.Psi.PsiManager.GetDeclarationsCache(JetBrains.ReSharper.Psi.Caches.IDeclarationsScope,System.Boolean)">PsiManager.GetDeclarationsCache</seealso>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache">
            <summary>
            Declarations cache provides access to cached information about types and namespaces.
            Depending on its scope declarations cache may provide information about types and namespaces
            <list>
            <item>in whole solution including libraries</item>
            <item>in whole solution exclusing libraries</item>
            <item>in project</item>
            <item>in project and its referenced libraries and projects</item>
            <item>in library and its referenced libraries</item>
            </list>
            </summary>
            <example>
            Following code demonstates use of <see cref="T:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache">IDeclarationsCache</see> indexer
            to get information about given class.
            <code>
            bool ClassIsSealed(string qualifiedName, ISolution solution)
            {
              DeclarationsCacheScope scope = DeclarationsCacheScope.SolutionScope(solution, false);
              IDeclarationsCache cache = PsiManager.GetInstance(solution).GetDeclarationsCache(scope);
              IDeclaredElementInfo info = cache[qualifiedName];
              Logger.Assert(info.GetSymbolType() == DeclaredElementType.CLASS);
              return info.IsSealed();
            }
            </code>
            </example>
            <seealso cref="T:JetBrains.ReSharper.Psi.Caches.DeclarationsScopeFactory">DeclarationsCacheScope</seealso>
            <seealso cref="T:JetBrains.ReSharper.Psi.IDeclaredElement">IDeclaredElementInfo</seealso>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetElementsAtQualifiedName(System.String)">
            <summary>
            Takes cached information about namespace or type with given <paramref name="qualifiedName">qualified name</paramref>
            and returns array with cached information about its nested namespaces and types
            (or just types if qualified name is a typename).
            </summary>
            <param name="qualifiedName">Full qualified name of namespace or type</param>
            <remarks>Returns information about default namespace if empty string is passed.
            <code>null</code> should not be passed (throws NullReferenceException).</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetAllShortNamesSorted">
            <summary>
            Returnes list of short names of all namespaces and types.
            Short name of a type is its declared name. Short name of a namespace is 
            last part of its name without dot, e.g. in the following code
            <code>
            namespace A.B
            {
            }
            </code>
            short name of namespace A.B is B.
            </summary>
            <returns>Lexicographically sorted array of all short names of namespaces and types.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetAllShortNames">
            <summary>
            Returnes list of short names of all namespaces and types.
            Short name of a type is its declared name. Short name of a namespace is 
            last part of its name without dot, e.g. in the following code
            <code>
            namespace A.B
            {
            }
            </code>
            short name of namespace A.B is B.
            </summary>
            <returns>List of all short names of namespaces and types.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetElementsByShortName(System.String)">
            <summary>
            Returns array of cached information about namespaces and types having given short name.
            (<see cref="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetAllShortNames">GetAllShortNames</see> for explanation of meaning of 'short name' term).
            </summary>
            <remarks>Empty arrray is returned if no elements with given name are found.
            Empty array is returned if <code>null</code> is passed.</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetPossibleInheritors(System.String)">
            <summary>
            Returns array of cached information about types that might directly inherit type
            with given short name. Type A is supposed that it might directly inherit type B if 
            it contains reference that might resolve to B in its extends list.
            Reference might resolve to type B if its name is short name of type B.
            GetPossibleInheritors takes aliases into consideration.
            <example>
            <code>
            using X = B;
            class A : B {}
            </code>
            Cached information for type A will be returned in calls to GetPossibleInheritors for type B.
            (And for type X if any exists in this declarations cache scope).
            </example>
            (<see cref="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetAllShortNames">GetAllShortNames</see> for explanation of meaning of 'short name' term).
            </summary>
            <param name="shortTypeName">short name of type</param>
            <remarks><paramref name="shortTypeName">short type name</paramref> should not be null</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.IDeclarationsCache.GetAllTypeMemberNames">
            <summary>
            Enumerates all possible names of the type members. The result could contains duplicate names, or names which do not match to any member
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.CodeAnnotationsCache.GetStringFormatMethodParameter(JetBrains.ReSharper.Psi.IMethod)">
            <summary>
            Get the format parameter of the string format method. Returns <c>null</c> if method is not string format method
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings">
            <summary>
            The component-like holder for all code style settings
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings.FileHeaderText">
            <summary>
            Get the copyright header of the file. Empty string means no copyright info
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettings.FileHeaderRegionName">
            <summary>
            Get if the copyright notice should be embraced in region. Empty region name means no embracement
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettingsAttribute">
            <summary>
            Specific code style settings (for specific language, for example) should be marked 
            by this attribute to be included in the code style settings container
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettingsManager">
            <summary>
            Component which is responsible to managing global code style settings
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettingsManager.CodeStyleSettings">
            <summary>
            Current code style settings container
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettingsSharing.USER">
            <summary>
            Code style settings are pre user
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettingsSharing.SOLUTION">
            <summary>
            Code style settings are shared in solution
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSettingsSharing.EXTERNAL">
            <summary>
            Code style settings are serialized to  external file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CodeStyle.SolutionCodeStyleSettings">
            <summary>
            Per-solution code style settings management
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementEnvoy`1">
            <summary>
            Represents <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> for presentations.
            </summary>
            <remarks>Provides ability to keep <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> presentation when element becomes invalid</remarks>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementEnvoy`1.Text">
            <summary>
            Gets presentation text for declared element, as was last generated via <see cref="M:JetBrains.ReSharper.Psi.DeclaredElementEnvoy`1.Present``1(JetBrains.UI.TreeView.StructuredPresenter{``0,JetBrains.CommonControls.IPresentableItem},``0,JetBrains.CommonControls.IPresentableItem,JetBrains.UI.TreeView.PresentationState)"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementType">
            <summary>
            Type of the declared element. Each type should be singleton
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.DeclaredElementType.IsPresentable(JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Returns presentation of this element is sound for given language type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementType.PresentableName">
            <summary>
            Presentable name of the declared element
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementType.Image">
            <summary>
            Image of the declared element
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementType.DefaultPresenter">
            <summary>
            Default declared element presenter
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IPathDeclaredElement.GetProjectItem">
            <summary>
            Returns random file at specified path
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExpectedTypes.CollectionTypeUtil.ElementTypeByCollectionType(JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.Resolve.IAccessContext)">
            <summary>
            Returns element type if collectionType is a _collection_type_ (described in specification, 15.8.4)
            otherwise, returns null
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ConvertibleFromConstraint">
            <summary>
            Base class for constraint which accepts all types assignable to a given type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ConvertibleFromExpressionTypeConstraint">
            <summary>
            Constraint implementation which accepts all types assignable to a given type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ConvertibleToConstraint">
            <summary>
            Base class for constraint which accepts all types assignable to a given type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.ExpectedType">
            <summary>
            Represents an expectation based on expression context
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.IsSubtypeOfConstraint">
            <summary>
            Accepts types which inherit from the specified type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.JoinConstraint">
            <summary>
            Joins multiple constraints (a type matches joined constraint 
            if it matches at least one of nested constraints)
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.ReferenceTypeConstraint">
            <summary>
            Constraint which accepts only reference types
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.CSharp.ExpectedTypes.SuperTypeConstraint">
            <summary>
            Constraint which accepts only super types of  a given type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeElement.GetSuperTypes">
            <summary>
            Immediate supertypes of the type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeElement.GetMembers">
            <summary>
            returns all members of this type (including nested types!)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeElement.GetContainingNamespace">
            <summary>
            Namespace containing this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.CLRName">
            <summary>
            Get the CLR name of type element.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.NestedTypes">
            <summary>
            returns all nested (= inner) types of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Constructors">
            <summary>
            returns all constructors of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Operators">
            <summary>
            returns all operators of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Methods">
            <summary>
            returns all methods of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Properties">
            <summary>
            returns all properties of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.Events">
            <summary>
            returns all events of this type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeElement.MemberNames">
            <summary>
            Get the names of all type members. 
            This set is approximate (i.e. it can contain extra names).
            Operator, Constructor and nested type names are not included in this list.
            It is much faster than getting all members itself
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ITypeMember.GetHiddenMembers">
            <summary>
            Find the members in supertypes which are hidden by this member
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeMember.AccessibilityDomain">
            <summary>
            Returns the accessibility domain of the type member, taking into account 
            the accessibility of the containing types
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeMember.HidePolicy">
            <summary>
            Get the hide policy
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Class.IClassPart.CustomConversionOperators">
            <summary>
            Check custom conversion operator presence. <see cref="!:Pair.First"/> refers to implicit operators, <see cref="!:Pair.Second"/> referes to explicit
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IParametersOwner">
            <summary>
            Represents a function-like construct that can be invoked.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <summary>
            Signature of the invocable. 
            </summary>
            <seealso cref="T:JetBrains.ReSharper.Psi.InvocableSignature"/>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IParametersOwner.Parameters">
            <summary>
            Set of formal parameters of the invocable
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IParametersOwner.ReturnType">
            <summary>
            Return type of the invocable 
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IInterface.CanBeInstantiated">
            <summary>
            Indicates if the interface can be instantiated using object creation expression
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IStruct.HasHiddenInstanceFields">
            <summary>
            Returns <c>true</c> if struct not all fields are returned in <see cref="P:JetBrains.ReSharper.Psi.IStruct.Fields"/> property.
            This could happen since private fields are not loaded through metadata
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Struct.IStructPart.CustomConversionOperators">
            <summary>
            Check custom conversion operator presence. <see cref="!:Pair.First"/> refers to implicit operators, <see cref="!:Pair.Second"/> referes to explicit
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.TypePart">
            <summary>
            Base class for language-dependent cached type decls
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Part">
            <summary>
            a node of cache tree 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.DeclarationPart.AssignDeclaredElement(JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2)">
            <summary>
            Implementations should override this method to bind their declarations to their declared elements
            </summary>
            <param name="declaration"></param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IExplicitImplementation">
            <summary>
            Reference to <see cref="T:JetBrains.ReSharper.Psi.IOverridableMember"/> explicit interface implementation
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IExplicitImplementation.Resolve">
            <summary>
            Resolve
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExplicitImplementation.DeclaringType">
            <summary>
            interface which contains implemented member
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IExplicitImplementation.MemberName">
            <summary>
            Name of implemented member
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Dependencies.IUsingsInfo">
            Implementors of this interface should have constructor with no parameters
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExpectedTypes.InvocationCandidate">
            <summary>
            An invocation target candidate for invocation context
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.CaseInsensitiveNamespaceRegistrar.myMap">
            keys are normalized qnames
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.KIND_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.INKIND_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind with "in" preposition.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.FROMKIND_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind with "from" preposition.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.KIND_NAME_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind and declared element name.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.NAME_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element name.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.KIND_QUALIFIED_NAME_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element entity kind and declared element qualified name.
            Designed for <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> and <see cref="T:JetBrains.ReSharper.Psi.INamespace"/>.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.DeclaredElementPresenter.QUALIFIED_NAME_PRESENTER">
            <summary>
            A presenter that returns strings containing declared element qualified name.
            Designed for <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> and <see cref="T:JetBrains.ReSharper.Psi.INamespace"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.DeclaredElementPresenter.MakeSmaller(JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle,System.String@,JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking@)">
            <summary>
            Tries to cut a long string with <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/> by replacing some of the closing parameters with "".
            </summary>
            <param name="presenter"></param>
            <param name="str">"Long" string containing a presentation of a <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/>.
            If cutting succeds the altered <code>str</code> contains a "shortened" presentation of the <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/>.</param>
            <param name="marking">Marking of a <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/>.
            If cutting succeds the altered <code>str</code> contains a "shortened" presentation of the <see cref="T:JetBrains.ReSharper.Psi.IParametersOwner"/>.</param>
            <returns><code>true</code> if succeds to shorten a string.</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IOverridableMember">
             <summary>
             Presents type member, that could be overridden. Currently overridable members are method,
             property, indexer and event.
             <list type="number">
             <item> SuperMember for class (struct) overridable member "foo" is class member that is overridden
                by "foo" or interface member that is implemented by "foo".
                
                Interface member cannot have supermembers. </item>
                
             <item> If "A" is a class, "I" is an interface, both "A" and "I" contains member "foo", class "B" extends
                "A" and implements "I", but "A" does not contain member "foo",
                then "I.foo" is QuasiSuperMember fo "A.foo"</item>
            
             <item> Let "A.foo" is supermember for "B.foo". If there is no "C.foo" such that "C.foo" is
                supermember for "B.foo" and "A.foo" is supermember foe "C.foo", then "A.foo" is immediate
                supermember for "B.foo".
            
                <para>All interface members are immediate supermembers.</para>
                <para>All quasisupermembers are immediate (quasi)supermembers.</para> </item>
                
             <item> If "A.foo" is supermember for "B.foo" and "A.foo" has no supermembers, then "A.foo" is root
                supermember for "B.foo".
                <para>All interface members are root supermembers.</para>
                <para>All quasisupermembers are root (quasi)supermembers.</para> </item>
             </list>
             </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IOverridableMember.IsExplicitImplementation">
            <summary>
            Returns <c>true</c> if this member is private implementation. See <see cref="P:JetBrains.ReSharper.Psi.IOverridableMember.ExplicitImplementations"/>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IOverridableMember.ExplicitImplementations">
            <summary>
            Returns the list of the members which are implemented explicitly
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IOverridableMember.CanBeImplicitImplementation">
            <summary>
            Returns true if this member can implement interface member implicitly
            </summary>
            Language-dependent property of IOverridableMember. Reflection implementations should return true.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.ISubstitution">
            <summary>
            Implements a valuation of type parameters
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.ISubstitution.Compose(JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <summary>Substitution composition: s.Compose([t->T]) = [t->s(T)]</summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Finder.TextOccurenceSearcherBase.Predicate">
            <summary>
            Get the predicate to check if the given node should be checked for text occurence
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.ICustomHandler">
            <summary>
            Base interface for language-specific custom handlers in write PSI and generated documents
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec">
            <summary>
            Part of the PSI write interface. 
            Provides the functionality to re-bind references when the subtree is inserted into physical tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.Encode(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Encode the references from the <paramref name="original"/> tree into the <paramref name="clone"/> tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.CopyWithResolve(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Create copy with preserving identity of ResolveResult
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.ExtractBindableReferences(JetBrains.ReSharper.Psi.Tree.IElement)">
            <summary>
            Try to extract reference from given element which could be bind
            </summary>
            <param name="element">Element to extract reference from</param>
            <returns>Array of references to the element itself (i.e. C in A.B.C), or empty array if no bindable reference found</returns>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.OnSubtreeInserted">
            <summary>
            Occurs when clone subtree is inserted into target, but reference identity is not yet started
            </summary>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.OnSetReferenceIdentity">
            <summary>
            Occurs during encoding when reference identity is set
            </summary>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.OnReferenceBinded">
            <summary>
            Occurs during decoding after reference was binded
            </summary>
        </member>
        <member name="E:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec.OnSetDeclarationIdentity">
            <summary>
            Called once after encoding and gices the match table between local declarations
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodec.myLocalDeclarations">
            <summary>
            Map from declared elements in original subtree into declaration in clone subtree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextDecoder.Decode">
            <summary>
            Decode the references when the clone is inserted into the real tree, and returns the clone position in the tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve2.Impl.ICascadingCache.Recall(System.Object,JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve2.Impl.ICalculationProcess@)">
            <summary>
            Returns cached value for key, or FORGET if recalculation is required
            </summary>
            <returns></returns>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve2.Impl.CascadingCache.myData">
            <summary>
            Data in this level of cache
            </summary>
            - No value for key means "look upstream if there is upstream, otherwise recalculate" 
            - Other value is calculated value
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.LocalModuleNamesFilter">
            <summary>
            Prefer symbols defined in given assembly if their FQN is the same
            Note: symbols from assembly with "Embed Interop Types = true" counted as locals
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IDocCommentReference.TagName">
            <summary>
            Tag name in which this reference occurs
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress">
            <summary>
            If a cache job wants to display more detailed progress while it's running, it can request a <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/>-based object from the <see cref="T:JetBrains.ReSharper.Psi.Impl.Caches2.CacheUpdateThread"/>.
            It must be <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>-ed before the job ends.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress.myNotifier">
            <summary>
            The owning notifier to which our display goes.
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress.myThread">
            <summary>
            Thread affinity.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress.#ctor(JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken,System.Func{System.Boolean},JetBrains.UI.Application.Progress.TaskThreadAffinity)">
            <summary>
            Creates a special progress for the cache work items.
            Ensures the progress is started/stopped appropriately and its threading is respected. Only progress and texts can be set in free-threaded manner.
            </summary>
            <param name="notifier">Owner of the global progress.</param>
            <param name="theCacheNotifierOwnershipCookie">Gives write access to the cache progress.</param>
            <param name="FIsCanceled">A function to check for canceling. Might be called on any thread, see <paramref name="threadaffinity"/>.</param>
            <param name="threadaffinity">Defines whether select methods are allowed to be called on another thread.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress.Enable(System.Double,System.Double,System.String)">
            <summary>
            Enables the progress while a job is running, mapping it to the range occupied by the job; disables on disposal.
            Must be called on the cache thread.
            </summary>
            <param name="rangestart">Subprogress range.</param>
            <param name="rangelength">Subprogress range.</param>
            <param name="sJobIdentity">The job identity, so that to include its name in error messages.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress.AssertApartmentThreadedCall">
            <summary>
            The call must be placed on the same thread this object was created on.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress.AssertFreeThreadedCall">
            <summary>
            This call can be placed on any thread, if allowed by <see cref="F:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress.myThreadAffinity"/>.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.CacheWorkItemSubprogress.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Caches2.DelegateJob">
            <summary>
            A cache thread work item, implemented by a delegate.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Caches.Job.Do(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Runs the task. The <paramref name="progress"/> should be used only if the task requires additional progress display (like smooth execution progress or more text messages). Normally, for short-time tasks, the executing engine will handle the progress.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.Job.Description">
            <summary>
            The individual description of the job. Not included into the status bar cache notifier.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Caches.Job.GroupId">
            <summary>
            Common ID for the group of jobs.
            It's the group progress that is displayed in the cache notifier, not jobs'.
            The group ID is displayed as the cache notifier main text (the only text of the status-bar cache notifier).
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.DelegateJob.#ctor(JetBrains.Util.Runnable,System.String)">
            <summary>
            Ctor.
            </summary>
            <param name="runnable">Job implementation.</param>
            <param name="name">Name for the job, to be displayed in the cache notifier.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.TakeOwnership(JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Sets the ownership over the notifier, so that it could not be modified without a token.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.WaitForCaches(System.String,System.String)">
            <summary>
            Syncroniously wait until caches are ready, with a popup progress window.
            Must be called under a read lock.
            </summary>
            <param name="sCallerName">Identifies the caller of the utility, so that he could understand the reason of the delay.</param>
            <param name="sCancelButtonContent">Title of the Cancel button, or <c>Null</c> if the Cancel button should be disabled.</param>
            <returns><c>True</c> if the caches are ready, <c>False</c> if user-cancelled.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.JetBrains#ComponentModel#IComponent#Init">
            <summary>
            <para>Initializes the component. Called by the component container after the component is created.</para>
            <para><see cref="M:System.IDisposable.Dispose"/> is the pairing method that's guaranteed to be called by the component container to tear down your component.</para>
            <para>You must not access other components before your <see cref="M:JetBrains.ComponentModel.IComponent.Init"/> method is called.</para>
            <para>All of the components that you access from <see cref="M:JetBrains.ComponentModel.IComponent.Init"/> are guaranteed to exist when your <see cref="M:System.IDisposable.Dispose"/> is called. Any other component might be missing by that time, and trying to get it will throw an exception.</para>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.Description">
            <summary>
            The additional (verbose comment) text for the notifier.
            This property can be set from any thread.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.Header">
            <summary>
            The main (title) text for the notifier.
            This property can be set from any thread.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.IsActive">
            <summary>
            Whether the cache notifier is current active.
            This means it should be visible on the screen, in either form, if additional conditions are met (eg VS window is active).
            This property can be set from any thread.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Caches2.PsiCacheNotifier.Progress">
            <summary>
            The progress value for the cache notifier, must be in the [01] range.
            This property can be set from any thread.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IFile.ReParse(JetBrains.ReSharper.Psi.TreeTextRange,System.String)">
            <summary>
            Incrementally reparse file
            </summary>
            <param name="modifiedRange">range in the old file text which is changed</param>
            <param name="text">text which should replace given range</param>
            <returns>the new file (may be the same)</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IFile.ToTreeNode">
            <summary>
            The same as <see cref="M:JetBrains.ReSharper.Psi.Tree.IElement.ToTreeNode"/> but with different return type.
            Just for convenience.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.IFile.ProjectFile">
            <summary>
            Returns project item containing this source element
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.IFile.CachingLexer">
            <summary>
            Obtains the caching lexer on file text
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.IFile.ModificationCounter">
            <summary>
            Starting from 0, each time the subtree is modified this counter increases
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.IFileImpl.ParsedDocumentTranslator">
            <summary>
            Translate ranges to parsed document. Under PSI transaction it will still return ranges in original parsed document, not shim one
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElementPresenter.Format(JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle,JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking@)">
            <param name="style"></param>
            <param name="element">Contains <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> to provide string presentation of.</param>
            <param name="substitution"></param>
            <param name="marking">Returns the markup of the string with a <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> presentation.</param>
             <summary>
             Returns a string containing declared element text presentation made according to this presenter settings.
             This method is usefull when additional processing is required for the returned string,
             e.g. as is done in the following method:
             <code>
             RichText Foo(IMethod method)
             {
               DeclaredElementPresenterMarking marking;
               RichTextParameters rtp = new RichTextParameters(ourFont);
               // make rich text with declared element presentation
               RichText result = new RichText(ourInvocableFormatter.Format(method, out marking),rtp);
               // highlight name of declared element in rich text
               result.SetColors(SystemColors.HighlightText,SystemColors.Info,marking.NameRange.StartOffset,marking.NameRange.EndOffset);
               return result;
             }
             </code>
             </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElementPresenter.Format(JetBrains.ReSharper.Psi.ParameterKind)">
            <summary>
            Returns language specific presentation for a given parameter kind 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IDeclaredElementPresenter.Format(JetBrains.ReSharper.Psi.AccessRights)">
            <summary>
            Returns language specific presentation for a given access rights value
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.TypeElementEqualityComparer">
            <summary>
            Check if given type elements equal.
            This will check possible runtime binding, i.e. 2 type elements from assemblies equals if their FQN equals, and assembly names are the same
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.TypeElementEqualityComparer.IsEqualEmbeddedComInteropTypes(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            http://msdn.microsoft.com/en-us/library/dd997297%28VS.100%29.aspx
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Elements.INamedElementsManager.GetAllElementKinds(JetBrains.ReSharper.Psi.PsiLanguageType)">
            <param name="language">'null' for language neutral element kinds</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Elements.NamedElementsBagAttribute.#ctor(System.String)">
            <param name="languageType">'null' for cross language elements</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Elements.NamedElementsManager.GetAllElementKinds(JetBrains.ReSharper.Psi.PsiLanguageType)">
            <param name="language">'null' for language neutral element kinds</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.Extentions.NameChangeUtil.GetSuggestedName(JetBrains.ReSharper.Psi.Naming.NameRoot,JetBrains.ReSharper.Psi.Naming.NameRoot,JetBrains.ReSharper.Psi.Naming.NameRoot)">
            <summary>
            
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.INamingLanguageService.ExpandAndShortenKeywords(System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.Naming.NameRoot})">
            <summary>
            Populates inbound collection with language specific keywords abbreviations and lowers priority.
            
            Sample:
              Inbound: int (Essential)
              Outbound: i (Essential), int (Inane)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Naming.INamingLanguageService.ConvertNameToUnmangledSafe(System.String)">
            <summary>
            Creates valid identifier and mangles name if necessary
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.NameWord.ourSkipTailInfix">
            <summary>
            ElementOfPointer -> Pointer
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.NameWord.ourPredefinedPrefixes">
            <summary>
            GetPointer -> Pointer
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Naming.NameWord.ourCollectionSuffixes">
            <summary>
            ElementList -> Element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IQualifier.GetSymbolTable(System.String[],JetBrains.ReSharper.Psi.Resolve.SymbolTableMode)">
            <param name="referenceNames">
            Names of the reference, for which the symbol table is built. 
            Array is empty if the table should not be filtered.
            </param>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.IQualifier.Resolved">
            <summary>
            False means failed to resolve
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.Caches.AbstractPersistentCache`2.Load(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Returns false in the following cases:
              - cache directory does not exist
              - cache format version did not match
              - one or more record's CRC did not match
              - total cache CRC did not match
              - IO problem occured
            In all these cases it automatically resets the cache on the disk to an empty one.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.MiscUtil.EnumerateChildNodes(JetBrains.ReSharper.Psi.Tree.IElement)">
            <summary>
            enumerates this node and all it's children
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.util.StringLiteralConverter">
            <summary>
            Summary description for StringLiteralConverter.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.util.StringLiteralConverter.CharSequence.#ctor(System.String)">
            <summary>
            Creates a new instance of CharEscape
            </summary>
            <param name="hex"></param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.CodeStyle.IGeneratedCodeRegionDetector">
            <summary>
            Should be used in copperation with recursive element processor to check generated code regions
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportReferenceType.IGNORE">
            <summary>
            Do not optimize this reference
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportReferenceType.SIGNATURE">
            <summary>
            Reference is signature reference
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportReferenceType.CODE_BLOCK">
            <summary>
            Reference is in code block
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.IOptimizeImportsServiceProvider.GetReferenceType(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IQualifiableReference,JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            Check if the given reference is located in code block, or in delcaration level
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportsEngine.Optimize(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.IPsiRangeMarker,System.Boolean,System.Boolean,JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Do optimize imports and shorten references. 
            Parameter <paramref name="rangeMarker"/> specifies range in file which is 
            affected by the process, or set it to <see cref="F:JetBrains.DocumentModel.DocumentRange.InvalidRange"/> 
            to process whole file
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportsEngine.OptimizeReferenceCollector">
            <summary>
            Collect and sort references which are affected bu optimze imports engine
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportsEngine.OptimizeReferenceCollector.Collect(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IQualifiableReference)">
            <summary>
            Returns true, if qualifier should not be visited
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PredefinedOperator.#ctor(JetBrains.ReSharper.Psi.PsiLanguageType,System.String,JetBrains.ReSharper.Psi.IType,System.Int32)">
            <summary>
            For creating operators with common type for parameters and return type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.ICompleteableReference.GetCompletionSymbolTable">
            <summary>
            Returns symbol table for code completion
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.TypeEquationsSolver">
            <summary>
            Depends on language specific implementation of the interface ITypeInferenceBoundsSolver
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Tree.ITypeArgumentsOwnerElement">
            <summary>
            Unifies cross-language reference names and reference expressions
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.CLRTypeConversionUtil.EffectiveBaseClass(JetBrains.ReSharper.Psi.ITypeParameter,System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.ITypeParameter})">
            <summary>
            </summary>
            <remarks>
            See corrected algorithm:
            https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=281842
            </remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.CLRTypeConversionUtil.VariantConvertible(JetBrains.ReSharper.Psi.IDeclaredType,JetBrains.ReSharper.Psi.IDeclaredType,System.Func{JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.IType,System.Boolean})">
            <summary>
            A type T{A1, , An} is variance-convertible to a type T{B1, , Bn} if T is either an interface or a delegate type declared with the variant type parameters T{X1, , Xn}, and for each variant type parameter Xi one of the following holds:
            	Xi is covariant and an implicit reference or identity conversion exists from Ai to Bi
            	Xi is contravariant and an implicit reference or identity conversion exists from Bi to Ai
            	Xi is invariant and an identity conversion exists from Ai to Bi
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.CLRTypeConversionUtil.MostEncompassedType(JetBrains.ReSharper.Psi.IType[])">
            <summary>
            Select the single type in the collection, which is implictly convertible to all others
            </summary>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions">
            <summary>
            Herlper methods to work with <see cref="T:JetBrains.ReSharper.Psi.Tree.ITreeNode"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.FindFirstTokenIn(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Returns first token, that supplied node consists of.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.FindLastTokenIn(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Returns last token, that supplied node consists of.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.ComparePositionTo(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Compare the position of two given nodes in the tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.FindPrevNode(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.TreeNodePredicate)">
            <summary>
            Returns first source element satisying the predicate and located before the current element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.FindNextNode(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.TreeNodePredicate)">
            <summary>
            Returns first tree node satisfying the predicate and located after the current node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions.GetNextMeaningfulChild(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Returns next child which is meaningful in the language (not a comment and not a whitespace)
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ControlFlow2.Impl.ControlFlowGraf.FixUp">
            <summary>
            Fixup graf into canonical representation. 
            Prepare reachable sequence for inspection and analyze reacability of elements
            Should be called from any inheritor constructor
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.PsiIconManagerImpl">
            <summary>
            Implementation for <see cref="T:JetBrains.ReSharper.Psi.PsiIconManager"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.PsiIconManager">
            <summary>
            Abstract interface for building model icon managers
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetDummyImage">
            <summary>
            Get the empty image of the typical size
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetImage(JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.PsiLanguageType,System.Boolean)">
            <summary>
            Gets image for declared element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetImage(JetBrains.ReSharper.Psi.DeclaredElementType)">
            <summary>
            Gets image by declared element type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetImage(JetBrains.ReSharper.Psi.DeclaredElementType,JetBrains.ReSharper.Psi.PsiIconExtension)">
            <summary>
            Gets image by declared element type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.ExtendToTypicalSize(System.Drawing.Image)">
            <summary>
            Extends the specified node image (16x16) to typical size
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiIconManager.GetAccessExtensions(JetBrains.ReSharper.Psi.AccessRights)">
            <summary>
            Get extension mask for given access rights
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.PsiIconManager.TypicalImageSize">
            <summary>
            Gets typical size of images produced by the manager
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IElementInstancePointer`1">
            <summary>
            A smart element which resurrects from model changes by tracking its location
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Search.ConstructorSpecialReferenceSearcher">
            <summary>
            Search for ":this()", ":base()" references....
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IProjectFileLanguageService.GetPsiLanguageType(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Evaluates PsiLanguageType for a file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IProjectFileLanguageService.GetPsiLanguageType(JetBrains.ProjectModel.ProjectFileType)">
            <summary>
            Returns most likely PsiLanguageType for a project file of corresponing ProjectFileType.
            i.e. XAML files normally return XAML psi, but sometimes may return XML psi, but this method should
            retrurn XAML
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.IProjectFileLanguageService.CreateLexer(JetBrains.Text.IBuffer,JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Creates lexer, that corresponds to source file text (NOT generated!) 
            </summary>
            <param name="buffer">IBuffer with the text</param>
            <param name="projectFile">Actual project file (if exists) for which the lexer is to be generated</param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IProjectFileLanguageService.SecondaryPsiLanguageTypes">
            <summary>
            Returns all possible secondary psi language types (i.e. both C# and VB for ASP)
            NB! there should be neither UNKNOWN language nor primary language
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IDerivedProjectFileLanguageService">
            <summary>
             The interface is used, when extension does not identify ProjectFileType 	unambiguously
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ProjectFileLanguageServiceAttribute.Extensions">
            <summary>
            File extensions, that identify ProjectFileType
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.ProjectFileLanguageServiceAttribute.IsDefault">
            <summary>
            IsDefault means that, the extensions identify the whole group of similar files (i.e. xml)
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.PsiIconExtension">
            <summary>
            Enumerates possible node types
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.PsiLanguageType.ANY">
            <summary>
            Specifies special language ID for services, which has semantic "for any language"
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.ElementAccessContext">
            <summary>
            IAccessContext implementation based on element
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IConstructor">
            <summary>
            Represents type constructor.
            <i>Note</i>: <c>ShortName</c> of all implementations should return <see cref="F:JetBrains.ReSharper.Psi.DeclaredElementConstants.CONSTRUCTOR_NAME"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Tree.IDefaultNamespaceOwner">
            <summary>
            This interface is implemented by <see cref="T:JetBrains.ReSharper.Psi.Tree.IFile"/> implementations when there is defaut namespace
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IDocCommentBlockNode.GetXML(JetBrains.ReSharper.Psi.ITypeMember)">
             <summary>
             Get the XML node for this doc comment, using given DeclaredElement as the header
             </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IDocCommentBlockNode.GetErrors">
            <summary>
            Get errors from XML parsing
            </summary>
            <returns>
            </returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IField.FixedBufferSize">
            <summary>
            In C#2.0 for field, check if this field is fixed-size buffer.
            Returns <c>null</c> if this is not fixed-size buffer, otherwise returns it's size
            If the field is fixed-size buffer, then it's type is a pointer to it's element
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.FileExtensions.Translate(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.DocumentModel.DocumentRange)">
            <summary>
            Translate coordinates in actual document into range in syncronized text
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.FileExtensions.Translate(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.DocumentModel.ProjectFileRange)">
            <summary>
            Translate coordinates in actual document into range in syncronized text
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.FileExtensions.GetProjectFileRange(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Translate the specified range in syncronized text into actual document range
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.FileExtensions.GetDocumentRange(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Translate the specified range in syncronized text into actual document range
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.FileExtensions.GetIntersectingRanges(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Get all ranges in actual document which intersects with given range in syncronized text
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.IIdentifierNode.Name">
            <summary>
            Returns name denoted by this identifier without language-specific stuff like '@' in C#
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.OverridableMemberExtensions.GetImmediateSuperMembers(JetBrains.ReSharper.Psi.IOverridableMember,System.Boolean)">
            <summary>
            Finds all immediate supermembers for this member.
            </summary>
            <param name="overridableMember"></param>
            <param name="searchQuasi">if true, returns quasisupermembers too.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.OverridableMemberExtensions.HasImmediateSuperMembers(JetBrains.ReSharper.Psi.IOverridableMember,System.Boolean)">
            <summary>
            Check if member has supers
            </summary>
            <param name="overridableMember"></param>
            <param name="searchQuasi">if true, returns quasisupermembers too.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.OverridableMemberExtensions.GetRootSuperMembers(JetBrains.ReSharper.Psi.IOverridableMember,System.Boolean)">
            <summary>
            Finds all root supermembers for this member.
            </summary>
            <param name="overridableMember"></param>
            <param name="searchQuasi">if true, returns quasisupermembers too.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.OverridableMemberExtensions.GetAllSuperMembers(JetBrains.ReSharper.Psi.IOverridableMember,System.Boolean)">
            <summary>
            Finds all supermembers for this member.
            </summary>
            <param name="overridableMember"></param>
            <param name="searchQuasi">if true, returns quasisupermembers too.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.OverridableMemberExtensions.OverridesOrImplements(JetBrains.ReSharper.Psi.IOverridableMember,JetBrains.ReSharper.Psi.IOverridableMember)">
            <summary>
            Checks if the given member is supermember
            </summary>
            <param name="derivedMember"></param>
            <param name="superMember"></param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Tree.INamespaceDeclaration.QualifiedName">
            <summary>
            Returns qualified name of the namespace this declaration declares
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TypeElementExtensions.IsDescendantOf(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Returns true if the type is (not necessary immediate) descendant of another type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TypeElementExtensions.GetMembers(JetBrains.ReSharper.Psi.ITypeElement,System.String)">
            <summary>
            returns all members of this type (including nested types!) with given name
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TypeElementExtensions.GetAllTypeParameters(JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            returns the enumerator through type parameters of this type and all container types
            </summary>
            Type parameters are enumerated in right-to-left, nested class first order
            In the following example
            <code>
            class A&lt;X,Y&gt;
            {
               class B&lt;Z,W&gt; {}
            }
            </code>
            AllTypeParameters for class B will be enumerated in order W,Z,Y,X
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TypeParameterVariance.INVARIANT">
            <summary>
            No variance
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TypeParameterVariance.IN">
            <summary>
            Contra-Variant, in
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TypeParameterVariance.OUT">
            <summary>
            Co-Variant, out
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Tree.IChameleonNode.ReSync(JetBrains.ReSharper.Psi.Parsing.CachingLexer,JetBrains.ReSharper.Psi.TreeTextRange,System.Int32)">
            <summary>
            Try to incrementally reparse the chameleon block
            </summary>
            <param name="cachingLexer">lexer of the new text</param>
            <param name="changedRange">range in text which is modified</param>
            <param name="insertedTextLen">Length of the inserted portion of the text</param>
            <returns>new chameleon if successfull. null if can't syncronize</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle">
            <summary>
            This class is a convertor from IDeclaredElement into presentable string with various options.
            </summary>
            Generally this class is used to prepare strings for displaying information to user as is done
            in the following code fragment:
            <code>
            class SomeClass
            {
              private static ourFormatter;
              
              static SomeClass()
              {
                ourFormatter  = new DeclaratedElementPresenter();
                // set desired options
                ourFormatter.ShowParameterTypes = true;
                ourFormatter.ShowParameterNames = true;
                ourFormatter.ShowBrackets = false;
              }
              
              public string[] Display(IDeclaredElement element)
              {
                System.Windows.Forms.MessageBox.Show("Readable presentation of IDeclaredElement : " + ourFormatter.Format(element));
              }
              public string[] Display(IDeclaredElementInfo info)
              {
                System.Windows.Forms.MessageBox.Show("Readable presentation of IDeclaredElementInfo : " + ourFormatter.Format(info));
              }
            }
            </code>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowAccessRights">
            <summary>
            Indicates if we should show acees rights of a <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/> (if any)
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowModifiers">
            <summary>
            Indicates if we should show the modifiers other rhan access rights <see cref="T:JetBrains.ReSharper.Psi.IDeclaredElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowParametersForDelegates">
            <summary>
            Indicates if we should show parameters for a <see cref="T:JetBrains.ReSharper.Psi.IDelegate"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowEntityKind">
            <summary>
            Indicates if the result string should contain element entity kind
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowName">
            <summary>
            Indicates if the result string should contain element name
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowTypeParameters">
            <summary>
            Indicates if type parameters should be shown
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowExplicitInterfaceQualification">
            <summary>
            Indicates if the explicit interface qualification should be shown before type member name
            This option is incompatible with ShowName == NameStyle.QUALIFIED
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowNameInQuotes">
            <summary>
            Indicates if the result string should contain element name (including signature, return type, etc.) enclosed in quotes
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowType">
            <summary>
            Indicates where and how 
            <list type="bullet">
            <item>type of a variable </item>
            <item>return type of a function</item>
            </list>
            should be inserted into result
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowParameterTypes">
            <summary>
            Indicates if the parameter list of a function should contain parameter types
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowParameterNames">
            <summary>
            Indicates if the parameter list of a function should contain parameter names
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowTypesQualified">
            <summary>
            Indicates if  
            <list type="bullet">
            <item>return type of a function</item>
            <item>parameter types of a function</item>
            <item>type of a variable</item>
            </list>
            should be fully qualified.
            Does not affect <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/>.
            To specify qualified names for <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> 
            use <see cref="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowTypeContainer"/> property.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowMemberContainer">
            <summary>
            Indicates where the container type of a type member should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.ITypeMember"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.MemberContainerQualified">
            <summary>
            Indicates how the container type of a type member should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.ITypeMember"/>.
            Workd only if 
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowTypeContainer">
            <summary>
            Indicates if the containing type or namespace of a <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/> should be shown and where it should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.ITypeElement"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowNamespaceContainer">
            <summary>
            Indicates if the containing namespace of a <see cref="T:JetBrains.ReSharper.Psi.INamespace"/> should be shown and where it should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.INamespace"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowParameterContainer">
            <summary>
            Indicates if the containing method of a <see cref="T:JetBrains.ReSharper.Psi.IParameter"/> should be shown and where it should be shown.
            Affects only <see cref="T:JetBrains.ReSharper.Psi.IParameter"/>.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.LengthLimit">
            <summary>
            Sets the output string length limit.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.LengthCheck">
            <summary>
            Returns interface for computing output string length
            Delagate for custom length checker. Length check is used to replace long parameter lists with "".
            <see cref="T:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle"/> is capable of calculating length itself (<see cref="M:JetBrains.ReSharper.Psi.DeclaredElementPresenter.MakeSmaller(JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle,System.String@,JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking@)"/>.
            However, if there are other length considerations (e.g. UI limitations) this class may be used.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle.ShowConstantValue">
            <summary>
            Indicates if the value of a constant is to be shown.
            Affects only constant.
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ProjectFilePart">
            <summary>
            Root of cached declarations tree for a file
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ProjectFilePart.GetRelevantDefines(System.Collections.Generic.IList{JetBrains.ReSharper.Psi.PreProcessingDirective})">
            <summary>
            Returns sorted array
            </summary>
            <param name="defines"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.NamespacePart">
            <summary>
            Base class for language-dependent cached namespace decls
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.TypeElementImplUtil.ComputeSubstitution(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Implemenatation of <a cref="!:ITypeElement.GetAncestorSubstitution"/>
            </summary>
            <param name="subtype"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.GeneratedDocumentServiceAttribute">
            <summary>
            Indicates that the marked class provides service for generated code-behind document
            The marked class should be
            <list type="number">
            <item>Interface of the solution-level component</item>
            <item>Implement the <see cref="T:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService"/></item>
            </list>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.CanHandle(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Checks, whether the file is handled by this service.
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.GetGeneratedText(JetBrains.ProjectModel.IProjectFile,JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.PsiLanguageType,JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.IRangeTranslator@)">
             <summary>
             Generates document for a file. File should be of correct type.
             </summary>
            <param name="projectFile"></param>
            <param name="primaryFile"></param>
            <param name="language">Language of the generated file</param>
            <param name="rangeTranslator"></param>
            <returns>Generated text, null if nothing to generate (i.e. wrong code-behind language)</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.OnGeneratedDocumentCopyChanged(JetBrains.ProjectModel.IProjectFile,JetBrains.Util.TextRange,System.String,System.String)">
             <summary>
             Called from transaction manager when temporary copy generated document is chaged
             </summary>
             <param name="file">
               project file for which the document is generated
            </param>
             <param name="range">
               replaced range in generated document
            </param>
             <param name="oldText"></param>
             <param name="newText">
               new text inserted into generated document
            </param>
             <returns>Transaction action that represents modification in real document</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.GetCustomHandler(JetBrains.ReSharper.Psi.PsiLanguageType)">
             <summary>
             Custom handler for write interface
             </summary>
            <param name="language">code-behind language</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.GetDisplayRange(JetBrains.ReSharper.Psi.Tree.IElement)">
            <summary>
            Custom naviagtion range, for instance for page declarations in ASP
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.StartCommitDocuments(System.Collections.Generic.IEnumerable{JetBrains.Util.Tuple{JetBrains.ProjectModel.IProjectFile,JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.DocumentModel.IDocument}})">
            <summary>
            Detects changes and applies changes in main thread
            </summary>
            <returns>null means nothing should be done for this service</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.WorkCommitDocuments(System.Object)">
            <summary>
            Performs background work (generate document text)
            </summary>
            <param name="startResult">Return value of StartCommitDocuments</param>
            <returns>null means nothing should be done for this service</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService.FinishCommitDocuments(System.Object)">
            <summary>
            Performs document changes on main thread
            </summary>
            <param name="workerResult">Return value of WorkCommitDocuments</param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ILightweightScope">
            <summary>
            Marker interface indicating that <see cref="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope.AddDeclarationsBeforeElement(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IWritableSymbolTable,JetBrains.ReSharper.Psi.Tree.IElement,System.Int32,JetBrains.ReSharper.Psi.Resolve.SymbolTableMode)"/> and <see cref="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope.AddDeclarationsAfterElement(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IWritableSymbolTable,JetBrains.ReSharper.Psi.Tree.IElement,System.Int32,JetBrains.ReSharper.Psi.Resolve.SymbolTableMode)"/>
            are empty
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IWritableSymbolTable.AddSymbol(JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope,System.Int32)">
            <summary>
              adds declared symbol into symbol table
            </summary>
            <param name="declaredElement">
              symbol to add into table
            </param>
            <param name="scope">
              visibility scope for added symbol
            </param>
            <param name="level">
              "depth level" of declared symbol
              for imported symbol (class or namespace)                          level = -1
              for namespaces and top-level classes without containing namespace level = 0
              for top-level classes with containing namespace                   level = 1
              for class members (including inner classes)                       level = level of containing class + 1
              for method parameters and local variables                         level = level of containing class + 2
            </param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IWritableSymbolTable.RemoveSymbols(JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope)">
            <summary>
              removes all symbols wtih visibility scope = scope
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.WritableSymbolTableBase.AddSymbolInternal(System.String,JetBrains.ReSharper.Psi.IDeclaredElement,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope,System.Int32,System.Nullable{System.Int32})">
            <summary>
            
            </summary>
            <param name="name">Normalized name</param>
            <param name="element"></param>
            <param name="substitution"></param>
            <param name="scope"></param>
            <param name="level"></param>
            <param name="inheritanceLevel"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.MultipleFilterSymbolTable">
            <summary>
            Filters symbol table with multiple filters
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.IParsedDocumentRangeTranslator">
            <summary>
            Document range translator
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.IParsedDocumentRangeTranslator.Translate(JetBrains.ReSharper.Psi.TreeTextRange)">
            <summary>
            Returns range in
            <list type="">
            <item>real document for "normal" PSIs</item>
            <item>generated document for code-behind PSIs </item>
            <item>null if cannot translate</item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecFactory">
            <summary>
            Base class for custom context codec factory.
            Every custom factory should be used only in 'using' statement shell
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceIdentitySaver.ClosureRemap(JetBrains.ReSharper.Psi.Resolve.IReference)">
            <summary>
            Do chain remap
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceIdentitySaver.PreviousIdentitySaver">
            <summary>
            User can set previous identity saver, so all events will be propagated to it
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.LowLevelModificationUtil">
            <summary>
            Methods to modify PSI tree with commiting changes to document through PSI manager
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ModificationUtil">
            <summary>
            Methods to modify PSI tree with reference re-binding
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ModificationUtil.ReplaceChild``1(JetBrains.ReSharper.Psi.Tree.ITreeNode,``0)">
            <summary>
            Warning: <paramref name="newChild"/> should not be child of <paramref name="oldChild"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ModificationUtil.CreateCopyWithResolve(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Create the copy of given ITreeNode under DummyHolder. All references are fake resolved
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ModificationUtil.DeferredDecode(System.Action)">
            <summary>
            Execute the action with the deferred context decoding
            </summary>
            <param name="action"></param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IArrayType">
            <summary>
            Interface for array types.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IArrayType.ElementType">
            <summary>
            Obtain type of the array elements.
            Example: returns "int" for "int[]".
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IArrayType.Rank">
            <summary>
            Get the rank (number of dimensions) of the array
            Examples:
              int[]   -> Rank == 1
              int[][] -> Rank == 1 (since it's an array with elements type "int[]")
              int[,]  -> Rank == 2
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IDeclaredElementPointer`1">
            <summary>
            A smart element which resurrects from model changes by tracking its location
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TrivialElementPointer`1">
            <summary>
            Implements trivial element pointer functinality
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.NonPhysicalElementPointer`1">
            <summary>
            Implements trivial element pointer functinality
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TrivialElementInstancePointer`1">
            <summary>
            Implements trivial element pointer functinality
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.INonCachableExpressionType">
            <summary>
            Marking interrface indicating that give expression type couldn't be cached
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ModifiersOwnerExtension.CanBeOverriden(JetBrains.ReSharper.Psi.IModifiersOwner)">
            <summary>
            Checks if entity either abstract, virtual or override. That is to say, it can be overriden in derived classes
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Caches2.PartsMap.PreprocessorDirectivesIndex.DirectivesAfterLastProjectChange">
            <summary>
            Always returns sorted directives
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.IWordIndexLanguageProvider.CaseSensitiveIdentifiers">
            <summary>
            If usages are case 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Caches2.CacheUpdateThread.JobGroupProgressTracker">
            <summary>
            Just tracks the progress within each job group.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Caches2.CacheUpdateThread.JobGroupProgressTracker.NextJob(System.Double@,System.Double@)">
            <summary>
            A new job is about to start. Calculates the cache notifier progress position for the job (<paramref name="jobrangestart"/>) and the amount of progress dedicated to this job (<paramref name="jobrangelen"/>).
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper.ReplaceSpaces(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode[])">
            <summary>
            Replaces spaces between two nodes by specified new nodes.
            </summary>
            <remarks>Copy from CSharpFormattingStage.ReplaceSpaces() with no algorithmic changes</remarks>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper.TrimRight(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Trim all left sibling nodes.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper.TrimLeft(JetBrains.ReSharper.Psi.Tree.ITreeNode)">
            <summary>
            Trim all left sibling nodes.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper.ComputeEndColumnOfNode(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.NodeTypeSet)">
            <summary>
            Calculates the end column of the given node. It is either
             - If node is multiline, the it the length of the first line
             - If the node is singleline, then it is the end position of the node
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper.HasTokenBetween(JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.Tree.ITreeNode,JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.NodeTypeSet)">
            <summary>
            Check if there are any of the given tokens set between two given nodes in the tree
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl.FindMembersInSuperInterfaces(JetBrains.ReSharper.Psi.OverridableMemberInstance,JetBrains.ReSharper.Psi.IDeclaredType,System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.IDeclaredType},System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.IDeclaredType})">
            <summary>
            find all interfaces of given type (except for ignored ones) which declared given member
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiFilesCache.UpdateAfterCommit(System.Collections.Generic.IEnumerable{JetBrains.ProjectModel.IProjectFile})">
            <summary>
            Update cached files buckets after commit. 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.WaitForCaches(System.String,System.String)">
            <summary>
            Syncroniously wait until caches are ready, with a popup progress window.
            Must be called under a read lock.
            </summary>
            <param name="sCallerName">Identifies the caller of the utility, so that he could understand the reason of the delay.</param>
            <param name="sCancelButtonContent">Title of the Cancel button.</param>
            <returns><c>True</c> if the caches are ready, <c>False</c> if user-cancelled.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.CreateDeclaredElementPointer``1(``0)">
            <summary>
            Creates the smart pointer to the declared element which probably could
            restore the the declared element after massive changes
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.GetGeneratedDocumentService(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Get the generated code-behind document service (if any) for the given project file.
            If no service is registered for this file, then returns <c>null</c>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.GetDocumentTextInTransaction(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Get the document text if the transaction will be commited
            </summary>
            <returns><c>null</c> if transaction couldn't be commited</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.DoTransaction(System.Action)">
            <summary>
            Do PSI write bulk operation.
            Upon success, ensure all modified documents are writable
            </summary>
            <returns>Status of attempt to modify involved documents</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.DoConditionaTransaction(System.Func{System.Boolean},System.String)">
            <summary>
            Do PSI write bulk operation. Commit if handler returns true
            Upon success, ensure all modified documents are writable
            </summary>
            <returns>Status of attempt to modify involved documents, or null if hadler returned false</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiManager.AddPsiCache(JetBrains.ReSharper.Psi.Impl.InvalidatingPsiCache)">
            <summary>
            Custom caches for PSIs
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.PsiManager.CachesIdle">
            <summary>
            Indicates if the async cache updater is idle right now
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.PsiManager.EnableAccessToUncommitedPsi">
            <summary>
            Enables clients to access uncommitted PSI files. Can be used because of performance reason e.g.
            when one cannot afford to commit PSI too often
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.PsiManager.PsiTimestamp">
            <summary>
            Timestamp for global PSI state
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.PsiManager.PsiCacheTimestamp">
            <summary>
            Timestamp for PSI-based caches. The difference from <see cref="P:JetBrains.ReSharper.Psi.PsiManager.PsiTimestamp"/> is that sometimes caches 
            should be completely invalidated without altering global PSI timestamp
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiManagerImpl.myDirtyProjectItems">
            <summary>
            Project items for which PSI is outdated
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiManagerImpl.GetSynchronizedDocument(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Returns temporary document if it was created or document, that is passed to the method
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiManagerImpl.AddTransactionAction(JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiTransactionAction,JetBrains.ReSharper.Psi.Tree.IElement,JetBrains.ReSharper.Psi.PsiChangedElementType)">
             <summary>
             Add new transaction action with change in PSI element.
             </summary>
             <param name="action"></param>
             <param name="elementContainingChanges">Element in PSI which incorporates changes in it's children.
             Pass <c>null</c> for major PSI changes</param>
            <param name="changedElementType"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiManagerImpl.AddTransactionAction(JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiTransactionAction)">
            <summary>
            Add transaction action with no change in PSI.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiManagerImpl.ReParse(JetBrains.ReSharper.Psi.Tree.IFile,JetBrains.ReSharper.Psi.TreeTextRange,System.String)">
            <summary>
            Incrementally reparse file.
            This is Write-PSI action!
            </summary>
            <param name="file">old file</param>
            <param name="modifiedRange">range in old file which is modified</param>
            <param name="newText">text which should replace the given range</param>
            <returns>The reparsed file. May be equal to the source one</returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiManagerImpl.IsCurrentTransactionFailed">
            <summary>
            True if FailTransaction method is called, thus the transaction will be rolled back
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiTransaction.DocumentModificationMap">
            <summary>
            Converts series of sequential document changes to optimized final document change map
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiTransaction.DocumentModificationMap.FindStartPoint(System.Int32,System.Int32@)">
            <summary>
            Try to find the right segment in the modified document
            Returns true if the point is inside modified segment, and <paramref name="segment"/> contains the segment index
            Returns false if the point is outside modified segment, and <paramref name="segment"/> contains the previous segment index
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiTransaction.DocumentModificationMap.FindEndPoint(System.Int32,System.Int32@)">
            <summary>
            Try to find the right segment in the modified document
            Returns true if the point is inside modified segment, and <paramref name="segment"/> contains the segment index
            Returns false if the point is outside modified segment, and <paramref name="segment"/> contains the next segment index
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.TemporaryDocumentsMap.BeforeDocumentChange(JetBrains.DocumentModel.IDocument)">
            <summary>
            Returns temporary document
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiTransactionActionUtil.GetOptimizedChange(JetBrains.DocumentModel.DocumentChange,System.String)">
             <summary>
             If the replaced text is the same at the beginning/ending, then do not modify that portion of text
             </summary>
            <param name="documentChange"></param>
            <param name="oldRangeText"></param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiTransactionManager">
            <summary>
            Manages nested PSI transactions
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.PsiManagerImpl.PsiTransactionManager.GetDocumentTextInTransaction(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Get the document text if tthe transaction will be commited.
            I.e. playback the transaction actions
            </summary>
            <returns><c>null</c> if transaction couldn't be commited</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PsiModuleManager.AreInternalsVisibleTo(JetBrains.ReSharper.Psi.IPsiModule,JetBrains.ReSharper.Psi.IPsiModule)">
            <summary>
            Checks if internals from <paramref name="moduleFrom"/> are visible to <paramref name="moduleTo"/>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Reflection2.Parameter.Next">
            <summary>
            Just for optimization. Parameters in methods are stored as single-linked list
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.TypeParameter.FindInheritedTypeParameterOfMethod">
            <summary>
            Tries to find the type parameter of the inherited method.
            According to C# specs 25.6.2
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.StaticEnumMethodsFilter">
            <summary>
            Filters our static methods of class object
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ResolveUtil.AddDeclarationsForProperDeclaredType(JetBrains.ReSharper.Psi.IDeclaredType,System.Int32,JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope,JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IWritableSymbolTable,System.Boolean,System.Boolean,JetBrains.ReSharper.Psi.Resolve.SymbolTableMode,System.Collections.Generic.HashSet{JetBrains.ReSharper.Psi.IDeclaredType})">
            <summary>
            "Proper" declared type means that it does not refer to type parameter
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Search.IFindResultConsumer`1.Build(JetBrains.ReSharper.Psi.Search.FindResult)">
            <summary>
            Transforms find result into user data. Can bind to PSI here. Method is unsyncronized.
            Returns <c>null</c> to skip result
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Search.IFindResultConsumer`1.Merge(`0)">
            <summary>
            Accepts data from <see cref="M:JetBrains.ReSharper.Psi.Search.IFindResultConsumer`1.Build(JetBrains.ReSharper.Psi.Search.FindResult)"/>. Method is syncronized.
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.FinderUtil.CollectAllPossibleNames(JetBrains.ReSharper.Psi.IDeclaredElement)">
            <summary>
            collects all names by which elements can be used in code
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.FinderUtil.NarrowSearchDomainByAllWords(JetBrains.ProjectModel.ISolution,JetBrains.ReSharper.Psi.Search.ISearchDomain,System.String[])">
            <summary>
            Narrow search domain to files which contains ALL of the given words
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Search.FinderUtil.GetInheritorsClosure(JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Get all names of the possible inheritors and it's count
            </summary>
            <param name="typeElement"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ExtensionsAPI.LanguageSpecificSearcherFactoryAttribute">
            <summary>
            Language-specific searcher factory should be marked by this attribute
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Search.OverridableSearchHelper`1">
            <summary>
            Helper class to search overriding/implementing member
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ITypeConversionRule">
            <summary>
            This interafce should be provided by language service. See <see cref="T:JetBrains.ReSharper.Psi.LanguageService"/>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.ArrayOfTokens.FindTokenAt(System.Int32)">
            <summary>
            Finds the token which covers the given position (i.e. offset in [start,end))
            </summary>
            <param name="offset"></param>
            <returns>Token index. Less than 0 if not found</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Parsing.DocumentUpdatesAccumulator">
            <summary>
            Accumulates incremental changes in the document
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Parsing.IIncrementalLexer.LexemIndent">
            <summary>
            Number of lexems that incremental re-lexing should step back to start relexing
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.LexerUtil.LookaheadToken(JetBrains.ReSharper.Psi.Parsing.ILexer,System.Int32)">
            <summary>
            Scan next k tokens
            </summary>
            <param name="lexer"></param>
            <param name="k"></param>
            <returns>Type of the k'th token</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.LexerUtil.GetCurrTokenText(JetBrains.ReSharper.Psi.Parsing.ILexer)">
            <summary>
            Get the text of the current token of the lexer
            </summary>
            <param name="lexer"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.TokenBuffer.ReScan(JetBrains.Util.TextRange,JetBrains.Text.BufferRange)">
            <summary>
            Rescans the buffer incrementally
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.TokenBuffer.ReScanInternalIncremental(JetBrains.Util.TextRange,System.Int32)">
            <returns>Range in document covering all changed tokens.</returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.TokenBuffer.ReScanInternalFull(JetBrains.Util.TextRange,System.Int32)">
            <returns>Range in document covering all changed tokens.</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Parsing.IXmlTokenBuilder">
            <summary>
            Implement this language-specific interface if you need specific behaviour
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.CanHasUserDefinedOperators(JetBrains.ReSharper.Psi.IType)">
            <summary>
            For optimization and fixing some problems
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsPredefinedNumeric(System.String)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong, decimal, double, float, char
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsPredefinedIntegral(System.String)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong, char or string
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsPredefinedIntegralNumeric(System.String)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsSimplePredefined(System.String)">
            <summary>
            Checks if given type equals to predefined string, bool, sbyte, byte, short, ushort, int, uint, long, ulong, decimal, double, float, char
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedType.IsSimplePredefinedClrName(System.String)">
            <summary>
            Checks if given type equals to predefined string, bool, sbyte, byte, short, ushort, int, uint, long, ulong, decimal, double, float, char
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedTypeExtensions.IsPredefinedNumeric(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong, decimal, double, float, char
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedTypeExtensions.IsPredefinedIntegral(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong, char or string
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedTypeExtensions.IsPredefinedIntegralNumeric(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if given type equals to predefined sbyte, byte, short, ushort, int, uint, long, ulong
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.PredefinedTypeExtensions.IsSimplePredefined(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Checks if given type equals to predefined string, bool, sbyte, byte, short, ushort, int, uint, long, ulong, decimal, double, float, char
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.Refers.NO">
            <summary>
            Late-bound reference could never be resolved to given declared element
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.Refers.MAYBE">
            <summary>
            Late-bound reference could be resolved to given declared element
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.Refers.YES">
            <summary>
            Late-bound reference actually is not late-bound (i.e. statically typed), and resolves to given element
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Resolve.IFileReference.ExpectedExtensions">
            <summary>
            If empty, no filtering by extension is done
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.IReferenceFactory">
            <summary>
            Custom reference provider
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReferenceFactory.GetReferences(JetBrains.ReSharper.Psi.Tree.IElement,JetBrains.ReSharper.Psi.Resolve.IReference[])">
            <summary>
            Incrementally update reference list.
            </summary>
            <param name="element"></param>
            <param name="oldReferences">Old references. Can be invalid.</param>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReferenceFactory.HasReference(JetBrains.ReSharper.Psi.Tree.IElement,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Returns <c>true</c> if this reference provider may have reference on element with one of given names
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.ReferenceProviderFactoryAttribute">
            <summary>
            Attribute for custom reference provider factory
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.IReferenceProviderFactory">
            <summary>
            Creates custom reference provider for given 
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.IReferenceProviderFactory.CreateFactory(JetBrains.ProjectModel.IProjectFile,JetBrains.ReSharper.Psi.Tree.IFile)">
            <summary>
            Creates implementation of <see cref="T:JetBrains.ReSharper.Psi.Resolve.IReferenceFactory"/> for the <paramref name="projectFile"/> and <paramref name="file"/>.
            </summary>
            <param name="projectFile">the specified project file</param>
            <param name="file">the specified PSI file</param>
            <returns>implementation of <see cref="T:JetBrains.ReSharper.Psi.Resolve.IReferenceFactory"/> or <c>null</c></returns>
            <remarks><paramref name="file"/>.IsValid() is <c>false</c> for this method call;</remarks>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.FilterRunType.REGULAR">
            <summary>
            Just regular filter
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.FilterRunType.MUST_RUN">
            <summary>
            Filter should be run, and if failed it produces candidates. 
            If failed on single result, the result doesnt become candidate!
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.FilterRunType.MUST_RUN_NO_CANDIDATES">
            <summary>
            Filter should be run, and if failed it doesn't produce candidates
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Resolve.SymbolTableMode">
            <summary>
            Used for symbol table builder. Determines if type members should be put into the rable
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.SymbolTableMode.TYPE_AND_NAMESPACES">
            <summary>
            Symbol table should contain only symbols, necessary for ReferenceName resolving. The vital that type members shouldn't be obtained
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.Resolve.SymbolTableMode.FULL">
            <summary>
            Complete symbol table - all necessary infos should be there
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.TypeInferenceUtil.ValidatePartialInferenceResultAgainstConstraints(JetBrains.ReSharper.Psi.Resolve.ISubstitution)">
            <summary>
            Validation of partial inference result for purposes of extension method symbol table filtering
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Resolve.TypeInferenceUtil.InferTypes(JetBrains.ReSharper.Psi.PsiLanguageType,JetBrains.ReSharper.Psi.IType,JetBrains.ReSharper.Psi.IType,System.Collections.Generic.ICollection{JetBrains.ReSharper.Psi.ITypeParameter})">
            <summary>
            Depends on language specific implementation of the interface ITypeInferenceBoundsSolver
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.TypeElementInheritanceCache.OnCachesChanged(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            Invalidate cache on Cache change
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.TypeElementInheritanceCache.IsDescendantOf(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.ITypeElement)">
            <summary>
            Determines if the given <paramref name="subType"/> is the descendant of the <paramref name="superType"/>
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Types.ArrayTypePointer">
            <summary>
            Holds pointer to an array type 
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ITypeDecorator">
            <summary>
            A type pointer which decorates another type pointer
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.ITypeDecorator.TypePointer">
            <summary>
            Get the underlying type pointer
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Types.ArrayTypePointer.TypePointer">
            <summary>
            Get the underlying type pointer
            </summary>  
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Types.DeclaredTypePointer">
            <summary>
            Type pointer for a declared type
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.IPointerType">
            <summary>
            Interface for unsafe code pointer type.
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.IPointerType.ElementType">
            <summary>
            Obtaing the underlying type, that is type of the element on which this pointer points.
            Example: for "int*" returns "int".
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Impl.Types.PointerTypePointer">
            <summary>
            Points to a pointer type
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.Impl.Types.PointerTypePointer.TypePointer">
            <summary>
            Get the underlying type pointer
            </summary> 
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Impl.Reflection2.XmlDocIndex.#ctor(JetBrains.ProjectModel.IAssembly,System.Boolean)">
            <summary>
            Builds index for compiled XML docs
            </summary>
            <param name="assembly">assembly to index doc for</param>
            <param name="sync">indicates wether indexing should be syncronious, or may execute in another thread</param>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.InvocableSignature">
            <summary>
            The signature (name + parameters) of IInvocable. Signature is used to identify matching
            invocables, that is to say, invocables which have the same set of parameters and the identical name.
            </summary>
            Two InvocableSignature's are equal if they have the same name, parameter types and parameter kinds.
            Methods <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/> are implemented 
            by this class to match the above definition.
            <seealso cref="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)"/>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.InvocableSignature.Null">
            <summary>
            Instance of InvocableSignature that can be used as null value
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.InvocableSignature.#ctor(JetBrains.ReSharper.Psi.IParametersOwner,JetBrains.ReSharper.Psi.Resolve.ISubstitution,JetBrains.ReSharper.Psi.InvocableSignature.ParameterKindCompareType)">
            <summary>
            Creates signature by an IInvocable. It's better to use <see cref="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)"/>.
            </summary>
            <param name="parametersOwner">Invocable to create signature for</param>
            <param name="substitution"></param>
            <param name="parameterKindCompareType"></param>
            <seealso cref="M:JetBrains.ReSharper.Psi.IParametersOwner.GetSignature(JetBrains.ReSharper.Psi.Resolve.ISubstitution)"/>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.InvocableSignature.GetParameterType(System.Int32)">
            <summary>
            Type of parameter with index <c>parameterIndex</c>
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.InvocableSignature.GetParameterKind(System.Int32)">
            <summary>
            Kind of parameter with index <c>parameterIndex</c>
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.InvocableSignature.Name">
            <summary>
            Name of IInvocable
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.InvocableSignature.ParameterCount">
            <summary>
            Parameter count of IInvocable
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:JetBrains.ReSharper.Psi.InvocableSignature.EqualitySubstitution" -->
        <member name="F:JetBrains.ReSharper.Psi.InvocableSignature.ParameterKindCompareType.STRICT">
            <summary>
            Strict parameter kind comparing, i.e. value, out and ref are all different
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.InvocableSignature.ParameterKindCompareType.VB_LIKE">
            <summary>
            Visual-Basic parameter kind comparing, where 'out' and 'ref' kinds are the same
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.LanguageService.IsTokenSkipped(JetBrains.ReSharper.Psi.Tree.ITokenNode)">
            <summary>
            returns true if the token is insignificant when expecting an expression selection
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.LanguageService.IsTypeMemberVisible(JetBrains.ReSharper.Psi.ITypeMember)">
            <summary>
            Check if the given type member is visible in this language
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.LanguageService.CodeFormatter">
            <summary>
            Get the code formatter
            </summary>
        </member>
        <member name="P:JetBrains.ReSharper.Psi.LanguageService.DeclaredElementPresenter">
            <summary>
            Provide language-specific presentation of the declared elements.
            Returns <c>null</c> if default presenter should be used
            </summary>
            You should never call this method directly. Use <cref>DeclaredElementPresenter.Format</cref>> instead.
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Parsing.IParser">
            <summary>
            Abstract parser interface
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Parsing.IParser.ParseFile(System.Boolean)">
            <summary>
            If a file contains non-trivial preprocessor or anything like that, RangeTranslator must be set befor file is returned
            </summary>
            <param name="forceOpenChameleon">whether to preopen chameleons</param>
            <returns>Parsed file</returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Parsing.ParserService">
            <summary>
            Utility class for accessing Parsing services
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TemporaryChangeCookie">
            <summary>
            Transaction for temporary change
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.PhysicalChangeCookie">
            <summary>
            Transaction, that will commit
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ControlledTransactionCookie">
            <summary>
            Controls that each and every transaction is either committed or rolled back
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.ISupportedByPSIChecker">
            <summary>
            Additional checking of whether given project file should be supported bu PSI
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.ISupportedByPSIChecker.Check(JetBrains.ProjectModel.IProjectFile)">
            <summary>
            If any of the registered checked answer <c>true</c> for the given project file, then PSI will be built
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Search.SearchAction">
            <summary>
            Handy class for running search actions
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TransactionResultEnum.SUCCESS">
            <summary>
            Transaction succeded
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TransactionResultEnum.FAILURE">
            <summary>
            Transaction failed due to some internal reasons
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TransactionResultEnum.CANCELLED">
            <summary>
            Transaction failed due to ProcessCancelledException is caught (usually, user press "cancel" button in progress window
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TransactionResultEnum.ENSURE_WRITABLE_FAILURE">
            <summary>
            The attempt to ensure writable failed for some files
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TransactionResultEnum.ENSURE_WRITABLE_CHANGES_DETECTED">
            <summary>
            Some files were modified as a result of the attempt to make them writable
            </summary>
        </member>
        <member name="F:JetBrains.ReSharper.Psi.TransactionResultEnum.ENSURE_WRITABLE_HAS_HIDDEN_FILES">
            <summary>
            There are hidden file, that cannot be modified, since they are generated by external build provider
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TypeFactory.CreateTypeWithDynamicSubsitution(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.IPsiModule)">
            <summary>
            Creates declared type from given type element with dynamic substitution, i.e. where any type parameter corresponds to dynamic type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.TypeFactory.CreateType(JetBrains.ReSharper.Psi.ITypeElement,JetBrains.ReSharper.Psi.IType[])">
            <summary>
            Creates a declared type for a given type element with given type parametre values
            </summary>
            Type parameter values should be specified for all type parameters of type element and its containing 
            type elements. They should appear in typeParameterValues array in outer-class-first, left-to-right order
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.TypePointerFactory">
            <summary>
            Class for creating type pointers on types
            </summary>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.Util.PersistentDataElementCollector`1">
            <summary>
            Collects all elements which have a data by the specified key
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TypesUtil.IsTrueValueType(JetBrains.ReSharper.Psi.IType)">
            <summary>
            Check if type is value non-nullable type
            </summary>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TypesUtil.MostEncompassedType(System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.IType},JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Select the single type in the collection, which is implictly convertible to all others
            </summary>
            <param name="types"></param>
            <param name="languageType"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.ReSharper.Psi.Util.TypesUtil.MostEncompassingType(System.Collections.Generic.IEnumerable{JetBrains.ReSharper.Psi.IType},JetBrains.ReSharper.Psi.PsiLanguageType)">
            <summary>
            Select the single type in the collection, to which all others are implicitly convertible
            </summary>
            <param name="types"></param>
            <param name="languageType"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.ReSharper.Psi.XmlIndex.XmlIndexingLexer">
            <summary>
            Xml file lexer with byte offset in file for each token
            </summary>
        </member>
    </members>
</doc>
